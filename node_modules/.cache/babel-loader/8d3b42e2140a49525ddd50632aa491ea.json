{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport cx from 'classnames';\nimport { css as glamorCss } from 'glamor';\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Positioner } from '../../positioner';\nimport { Tooltip } from '../../tooltip';\nimport { Position } from '../../constants';\nimport PopoverStateless from './PopoverStateless';\n\nvar Popover = /*#__PURE__*/function (_Component) {\n  _inherits(Popover, _Component);\n\n  function Popover(props) {\n    var _this;\n\n    _classCallCheck(this, Popover);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Popover).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_this), \"bringFocusInside\", function () {\n      // Always delay focus manipulation to just before repaint to prevent scroll jumping\n      return requestAnimationFrame(function () {\n        // Container ref may be undefined between component mounting and Portal rendering\n        // activeElement may be undefined in some rare cases in IE\n        if (_this.popoverNode == null || // eslint-disable-line eqeqeq, no-eq-null\n        document.activeElement == null || // eslint-disable-line eqeqeq, no-eq-null\n        !_this.state.isShown) {\n          return;\n        }\n\n        var isFocusOutsideModal = !_this.popoverNode.contains(document.activeElement);\n\n        if (isFocusOutsideModal) {\n          // Element marked autofocus has higher priority than the other clowns\n          var autofocusElement = _this.popoverNode.querySelector('[autofocus]');\n\n          var wrapperElement = _this.popoverNode.querySelector('[tabindex]');\n\n          var buttonElements = _this.popoverNode.querySelectorAll('button, a, [role=\"menuitem\"], [role=\"menuitemradio\"]');\n\n          if (autofocusElement) {\n            autofocusElement.focus();\n          } else if (wrapperElement) {\n            wrapperElement.focus();\n          } else if (buttonElements.length > 0) {\n            buttonElements[0].focus();\n          }\n        }\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"bringFocusBackToTarget\", function () {\n      return requestAnimationFrame(function () {\n        if (_this.popoverNode == null || // eslint-disable-line eqeqeq, no-eq-null\n        document.activeElement == null // eslint-disable-line eqeqeq, no-eq-null\n        ) {\n            return;\n          }\n\n        var isFocusInsideModal = _this.popoverNode.contains(document.activeElement); // Bring back focus on the target.\n\n\n        if (_this.targetRef && (document.activeElement === document.body || isFocusInsideModal)) {\n          _this.targetRef.focus();\n        }\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onBodyClick\", function (e) {\n      // Ignore clicks on the popover or button\n      if (_this.targetRef && _this.targetRef.contains(e.target)) {\n        return;\n      }\n\n      if (_this.popoverNode && _this.popoverNode.contains(e.target)) {\n        return;\n      } // Notify body click\n\n\n      _this.props.onBodyClick(e);\n\n      if (_this.props.shouldCloseOnExternalClick === false) {\n        return;\n      }\n\n      _this.close();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onEsc\", function (e) {\n      // Esc key\n      if (e.keyCode === 27) {\n        _this.close();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"toggle\", function () {\n      if (_this.state.isShown) {\n        _this.close();\n      } else {\n        _this.open();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"open\", function () {\n      if (_this.state.isShown) {\n        return;\n      }\n\n      _this.setState({\n        isShown: true\n      });\n\n      document.body.addEventListener('click', _this.onBodyClick, false);\n      document.body.addEventListener('keydown', _this.onEsc, false);\n\n      _this.props.onOpen();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"close\", function () {\n      if (!_this.state.isShown) {\n        return;\n      }\n\n      _this.setState({\n        isShown: false\n      });\n\n      document.body.removeEventListener('click', _this.onBodyClick, false);\n      document.body.removeEventListener('keydown', _this.onEsc, false);\n\n      _this.bringFocusBackToTarget();\n\n      _this.props.onClose();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleOpenComplete\", function () {\n      if (_this.props.bringFocusInside) _this.bringFocusInside();\n\n      _this.props.onOpenComplete();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleCloseComplete\", function () {\n      _this.props.onCloseComplete();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleKeyDown\", function (e) {\n      if (e.key === 'ArrowDown') {\n        _this.bringFocusInside();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleOpenHover\", function () {\n      if (_this.props.trigger === 'hover') {\n        _this.open();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleCloseHover\", function () {\n      if (_this.props.trigger === 'hover') {\n        _this.close();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"renderTarget\", function (_ref) {\n      var getRef = _ref.getRef,\n          isShown = _ref.isShown;\n      var children = _this.props.children;\n      var isTooltipInside = children && children.type === Tooltip;\n\n      var getTargetRef = function getTargetRef(ref) {\n        _this.targetRef = ref;\n        getRef(ref);\n      };\n      /**\n       * When a function is passed, you can control the Popover manually.\n       */\n\n\n      if (typeof children === 'function') {\n        return children({\n          toggle: _this.toggle,\n          getRef: getTargetRef,\n          isShown: isShown\n        });\n      }\n\n      var popoverTargetProps = {\n        onClick: _this.toggle,\n        onMouseEnter: _this.handleOpenHover,\n        onKeyDown: _this.handleKeyDown,\n        role: 'button',\n        'aria-expanded': isShown,\n        'aria-haspopup': true\n      };\n      /**\n       * Tooltips can be used within a Popover (not the other way around)\n       * In this case the children is the Tooltip instead of a button.\n       * Pass the properties to the Tooltip and let the Tooltip\n       * add the properties to the target.\n       */\n\n      if (isTooltipInside) {\n        return React.cloneElement(children, {\n          popoverProps: _objectSpread({\n            getTargetRef: getTargetRef,\n            isShown: isShown\n          }, popoverTargetProps)\n        });\n      }\n      /**\n       * With normal usage only popover props end up on the target.\n       */\n\n\n      return React.cloneElement(children, _objectSpread({\n        innerRef: getTargetRef\n      }, popoverTargetProps));\n    });\n\n    _this.state = {\n      isShown: props.isShown\n    };\n    return _this;\n  }\n\n  _createClass(Popover, [{\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      document.body.removeEventListener('click', this.onBodyClick, false);\n      document.body.removeEventListener('keydown', this.onEsc, false);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var isShown = this.props.isShown; // If `isShown` is a boolean, popover is controlled manually.\n      // In that case, ensure that `open` or `close` functionality is applied\n\n      if (typeof isShown === 'boolean' && isShown !== prevProps.isShown) {\n        if (isShown) {\n          this.open();\n        } else {\n          this.close();\n        }\n      }\n    }\n    /**\n     * Methods borrowed from BlueprintJS\n     * https://github.com/palantir/blueprint/blob/release/2.0.0/packages/core/src/components/overlay/overlay.tsx\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          isShown = _this$props.isShown,\n          content = _this$props.content,\n          display = _this$props.display,\n          minWidth = _this$props.minWidth,\n          position = _this$props.position,\n          minHeight = _this$props.minHeight,\n          _this$props$stateless = _this$props.statelessProps,\n          statelessProps = _this$props$stateless === void 0 ? {} : _this$props$stateless,\n          animationDuration = _this$props.animationDuration,\n          onCloseComplete = _this$props.onCloseComplete;\n      var stateIsShown = this.state.isShown; // If `isShown` is a boolean, popover is controlled manually, not via mouse events\n\n      var shown = typeof isShown === 'boolean' ? isShown : stateIsShown;\n      return React.createElement(Positioner, {\n        target: function target(_ref2) {\n          var getRef = _ref2.getRef,\n              isShown = _ref2.isShown,\n              targetWidth = _ref2.targetWidth;\n          return _this2.renderTarget({\n            getRef: getRef,\n            isShown: isShown,\n            targetWidth: targetWidth\n          });\n        },\n        isShown: shown,\n        position: position,\n        animationDuration: animationDuration,\n        onOpenComplete: this.handleOpenComplete,\n        onCloseComplete: onCloseComplete\n      }, function (_ref3) {\n        var css = _ref3.css,\n            style = _ref3.style,\n            state = _ref3.state,\n            getRef = _ref3.getRef;\n        return React.createElement(PopoverStateless, _extends({\n          innerRef: function innerRef(ref) {\n            _this2.popoverNode = ref;\n            getRef(ref);\n          },\n          \"data-state\": state,\n          display: display,\n          minWidth: minWidth,\n          minHeight: minHeight\n        }, statelessProps, {\n          className: cx(statelessProps.className, css ? glamorCss(css).toString() : undefined),\n          style: statelessProps && statelessProps.style ? _objectSpread({}, style, {}, statelessProps.style) : style,\n          onMouseLeave: _this2.handleCloseHover\n        }), typeof content === 'function' ? content({\n          close: _this2.close\n        }) : content);\n      });\n    }\n  }]);\n\n  return Popover;\n}(Component);\n\nPopover.displayName = \"Popover\";\n\n_defineProperty(Popover, \"propTypes\", {\n  /**\n   * The position the Popover is on. Smart positioning might override this.\n   */\n  position: PropTypes.oneOf([Position.TOP, Position.TOP_LEFT, Position.TOP_RIGHT, Position.BOTTOM, Position.BOTTOM_LEFT, Position.BOTTOM_RIGHT, Position.LEFT, Position.RIGHT]),\n\n  /**\n   * When true, the Popover is manually shown.\n   */\n  isShown: PropTypes.bool,\n\n  /**\n   * Open the Popover based on click or hover. Default is click.\n   */\n  trigger: PropTypes.oneOf(['click', 'hover']),\n\n  /**\n   * The content of the Popover.\n   */\n  content: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,\n\n  /**\n   * The target button of the Popover.\n   * When a function the following arguments are passed:\n   * ({ toggle: Function -> Void, getRef: Function -> Ref, isShown: Bool })\n   */\n  children: PropTypes.oneOfType([PropTypes.element, PropTypes.func]).isRequired,\n\n  /**\n   * The display property passed to the Popover card.\n   */\n  display: PropTypes.string,\n\n  /**\n   * The min width of the Popover card.\n   */\n  minWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n\n  /**\n   * The min height of the Popover card.\n   */\n  minHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n\n  /**\n   * Properties passed through to the Popover card.\n   */\n  statelessProps: PropTypes.shape(PopoverStateless.propTypes),\n\n  /**\n   * Duration of the animation.\n   */\n  animationDuration: PropTypes.number,\n\n  /**\n   * Function called when the Popover opens.\n   */\n  onOpen: PropTypes.func.isRequired,\n\n  /**\n   * Function fired when Popover closes.\n   */\n  onClose: PropTypes.func.isRequired,\n\n  /**\n   * Function that will be called when the enter transition is complete.\n   */\n  onOpenComplete: PropTypes.func.isRequired,\n\n  /**\n   * Function that will be called when the exit transition is complete.\n   */\n  onCloseComplete: PropTypes.func.isRequired,\n\n  /**\n   * Function that will be called when the body is clicked.\n   */\n  onBodyClick: PropTypes.func.isRequired,\n\n  /**\n   * When true, bring focus inside of the Popover on open.\n   */\n  bringFocusInside: PropTypes.bool,\n\n  /**\n   * Boolean indicating if clicking outside the dialog should close the dialog.\n   */\n  shouldCloseOnExternalClick: PropTypes.bool\n});\n\n_defineProperty(Popover, \"defaultProps\", {\n  position: Position.BOTTOM,\n  minWidth: 200,\n  minHeight: 40,\n  animationDuration: 300,\n  onOpen: function onOpen() {},\n  onClose: function onClose() {},\n  onOpenComplete: function onOpenComplete() {},\n  onCloseComplete: function onCloseComplete() {},\n  onBodyClick: function onBodyClick() {},\n  bringFocusInside: false,\n  shouldCloseOnExternalClick: true,\n  trigger: 'click'\n});\n\nexport { Popover as default };","map":{"version":3,"sources":["../../../src/popover/src/Popover.js"],"names":["css","Popover","Component","position","PropTypes","Position","isShown","trigger","content","children","display","minWidth","minHeight","statelessProps","PopoverStateless","animationDuration","onOpen","onClose","onOpenComplete","onCloseComplete","onBodyClick","bringFocusInside","shouldCloseOnExternalClick","bool","props","document","prevProps","requestAnimationFrame","isFocusOutsideModal","autofocusElement","wrapperElement","buttonElements","isFocusInsideModal","e","getRef","isTooltipInside","getTargetRef","toggle","popoverTargetProps","onClick","onMouseEnter","onKeyDown","role","popoverProps","innerRef","stateIsShown","shown","targetWidth","style","state","cx","glamorCss","handleCloseHover","close"],"mappings":"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","sourcesContent":["import cx from 'classnames'\nimport { css as glamorCss } from 'glamor'\nimport React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { Positioner } from '../../positioner'\nimport { Tooltip } from '../../tooltip'\nimport { Position } from '../../constants'\nimport PopoverStateless from './PopoverStateless'\n\nexport default class Popover extends Component {\n  static propTypes = {\n    /**\n     * The position the Popover is on. Smart positioning might override this.\n     */\n    position: PropTypes.oneOf([\n      Position.TOP,\n      Position.TOP_LEFT,\n      Position.TOP_RIGHT,\n      Position.BOTTOM,\n      Position.BOTTOM_LEFT,\n      Position.BOTTOM_RIGHT,\n      Position.LEFT,\n      Position.RIGHT\n    ]),\n\n    /**\n     * When true, the Popover is manually shown.\n     */\n    isShown: PropTypes.bool,\n    /**\n     * Open the Popover based on click or hover. Default is click.\n     */\n    trigger: PropTypes.oneOf(['click', 'hover']),\n\n    /**\n     * The content of the Popover.\n     */\n    content: PropTypes.oneOfType([PropTypes.node, PropTypes.func]).isRequired,\n\n    /**\n     * The target button of the Popover.\n     * When a function the following arguments are passed:\n     * ({ toggle: Function -> Void, getRef: Function -> Ref, isShown: Bool })\n     */\n    children: PropTypes.oneOfType([PropTypes.element, PropTypes.func])\n      .isRequired,\n\n    /**\n     * The display property passed to the Popover card.\n     */\n    display: PropTypes.string,\n\n    /**\n     * The min width of the Popover card.\n     */\n    minWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n\n    /**\n     * The min height of the Popover card.\n     */\n    minHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n\n    /**\n     * Properties passed through to the Popover card.\n     */\n    statelessProps: PropTypes.shape(PopoverStateless.propTypes),\n\n    /**\n     * Duration of the animation.\n     */\n    animationDuration: PropTypes.number,\n\n    /**\n     * Function called when the Popover opens.\n     */\n    onOpen: PropTypes.func.isRequired,\n\n    /**\n     * Function fired when Popover closes.\n     */\n    onClose: PropTypes.func.isRequired,\n\n    /**\n     * Function that will be called when the enter transition is complete.\n     */\n    onOpenComplete: PropTypes.func.isRequired,\n\n    /**\n     * Function that will be called when the exit transition is complete.\n     */\n    onCloseComplete: PropTypes.func.isRequired,\n\n    /**\n     * Function that will be called when the body is clicked.\n     */\n    onBodyClick: PropTypes.func.isRequired,\n\n    /**\n     * When true, bring focus inside of the Popover on open.\n     */\n    bringFocusInside: PropTypes.bool,\n\n    /**\n     * Boolean indicating if clicking outside the dialog should close the dialog.\n     */\n    shouldCloseOnExternalClick: PropTypes.bool\n  }\n\n  static defaultProps = {\n    position: Position.BOTTOM,\n    minWidth: 200,\n    minHeight: 40,\n    animationDuration: 300,\n    onOpen: () => {},\n    onClose: () => {},\n    onOpenComplete: () => {},\n    onCloseComplete: () => {},\n    onBodyClick: () => {},\n    bringFocusInside: false,\n    shouldCloseOnExternalClick: true,\n    trigger: 'click'\n  }\n\n  constructor(props) {\n    super(props)\n    this.state = {\n      isShown: props.isShown\n    }\n  }\n\n  componentWillUnmount() {\n    document.body.removeEventListener('click', this.onBodyClick, false)\n    document.body.removeEventListener('keydown', this.onEsc, false)\n  }\n\n  componentDidUpdate(prevProps) {\n    const { isShown } = this.props\n    // If `isShown` is a boolean, popover is controlled manually.\n    // In that case, ensure that `open` or `close` functionality is applied\n    if (typeof isShown === 'boolean' && isShown !== prevProps.isShown) {\n      if (isShown) {\n        this.open()\n      } else {\n        this.close()\n      }\n    }\n  }\n\n  /**\n   * Methods borrowed from BlueprintJS\n   * https://github.com/palantir/blueprint/blob/release/2.0.0/packages/core/src/components/overlay/overlay.tsx\n   */\n  bringFocusInside = () => {\n    // Always delay focus manipulation to just before repaint to prevent scroll jumping\n    return requestAnimationFrame(() => {\n      // Container ref may be undefined between component mounting and Portal rendering\n      // activeElement may be undefined in some rare cases in IE\n      if (\n        this.popoverNode == null || // eslint-disable-line eqeqeq, no-eq-null\n        document.activeElement == null || // eslint-disable-line eqeqeq, no-eq-null\n        !this.state.isShown\n      ) {\n        return\n      }\n\n      const isFocusOutsideModal = !this.popoverNode.contains(\n        document.activeElement\n      )\n      if (isFocusOutsideModal) {\n        // Element marked autofocus has higher priority than the other clowns\n        const autofocusElement = this.popoverNode.querySelector('[autofocus]')\n        const wrapperElement = this.popoverNode.querySelector('[tabindex]')\n        const buttonElements = this.popoverNode.querySelectorAll(\n          'button, a, [role=\"menuitem\"], [role=\"menuitemradio\"]'\n        )\n\n        if (autofocusElement) {\n          autofocusElement.focus()\n        } else if (wrapperElement) {\n          wrapperElement.focus()\n        } else if (buttonElements.length > 0) {\n          buttonElements[0].focus()\n        }\n      }\n    })\n  }\n\n  bringFocusBackToTarget = () => {\n    return requestAnimationFrame(() => {\n      if (\n        this.popoverNode == null || // eslint-disable-line eqeqeq, no-eq-null\n        document.activeElement == null // eslint-disable-line eqeqeq, no-eq-null\n      ) {\n        return\n      }\n\n      const isFocusInsideModal = this.popoverNode.contains(\n        document.activeElement\n      )\n\n      // Bring back focus on the target.\n      if (\n        this.targetRef &&\n        (document.activeElement === document.body || isFocusInsideModal)\n      ) {\n        this.targetRef.focus()\n      }\n    })\n  }\n\n  onBodyClick = e => {\n    // Ignore clicks on the popover or button\n    if (this.targetRef && this.targetRef.contains(e.target)) {\n      return\n    }\n\n    if (this.popoverNode && this.popoverNode.contains(e.target)) {\n      return\n    }\n\n    // Notify body click\n    this.props.onBodyClick(e)\n\n    if (this.props.shouldCloseOnExternalClick === false) {\n      return\n    }\n\n    this.close()\n  }\n\n  onEsc = e => {\n    // Esc key\n    if (e.keyCode === 27) {\n      this.close()\n    }\n  }\n\n  toggle = () => {\n    if (this.state.isShown) {\n      this.close()\n    } else {\n      this.open()\n    }\n  }\n\n  open = () => {\n    if (this.state.isShown) {\n      return\n    }\n\n    this.setState({ isShown: true })\n    document.body.addEventListener('click', this.onBodyClick, false)\n    document.body.addEventListener('keydown', this.onEsc, false)\n\n    this.props.onOpen()\n  }\n\n  close = () => {\n    if (!this.state.isShown) {\n      return\n    }\n\n    this.setState({ isShown: false })\n    document.body.removeEventListener('click', this.onBodyClick, false)\n    document.body.removeEventListener('keydown', this.onEsc, false)\n\n    this.bringFocusBackToTarget()\n    this.props.onClose()\n  }\n\n  handleOpenComplete = () => {\n    if (this.props.bringFocusInside) this.bringFocusInside()\n    this.props.onOpenComplete()\n  }\n\n  handleCloseComplete = () => {\n    this.props.onCloseComplete()\n  }\n\n  handleKeyDown = e => {\n    if (e.key === 'ArrowDown') {\n      this.bringFocusInside()\n    }\n  }\n\n  handleOpenHover = () => {\n    if (this.props.trigger === 'hover') {\n      this.open()\n    }\n  }\n\n  handleCloseHover = () => {\n    if (this.props.trigger === 'hover') {\n      this.close()\n    }\n  }\n\n  renderTarget = ({ getRef, isShown }) => {\n    const { children } = this.props\n    const isTooltipInside = children && children.type === Tooltip\n\n    const getTargetRef = ref => {\n      this.targetRef = ref\n      getRef(ref)\n    }\n\n    /**\n     * When a function is passed, you can control the Popover manually.\n     */\n    if (typeof children === 'function') {\n      return children({\n        toggle: this.toggle,\n        getRef: getTargetRef,\n        isShown\n      })\n    }\n\n    const popoverTargetProps = {\n      onClick: this.toggle,\n      onMouseEnter: this.handleOpenHover,\n      onKeyDown: this.handleKeyDown,\n      role: 'button',\n      'aria-expanded': isShown,\n      'aria-haspopup': true\n    }\n\n    /**\n     * Tooltips can be used within a Popover (not the other way around)\n     * In this case the children is the Tooltip instead of a button.\n     * Pass the properties to the Tooltip and let the Tooltip\n     * add the properties to the target.\n     */\n    if (isTooltipInside) {\n      return React.cloneElement(children, {\n        popoverProps: {\n          getTargetRef,\n          isShown,\n\n          // These propeties will be spread as `popoverTargetProps`\n          // in the Tooltip component.\n          ...popoverTargetProps\n        }\n      })\n    }\n\n    /**\n     * With normal usage only popover props end up on the target.\n     */\n    return React.cloneElement(children, {\n      innerRef: getTargetRef,\n      ...popoverTargetProps\n    })\n  }\n\n  render() {\n    const {\n      isShown,\n      content,\n      display,\n      minWidth,\n      position,\n      minHeight,\n      statelessProps = {},\n      animationDuration,\n      onCloseComplete\n    } = this.props\n    const { isShown: stateIsShown } = this.state\n\n    // If `isShown` is a boolean, popover is controlled manually, not via mouse events\n    const shown = typeof isShown === 'boolean' ? isShown : stateIsShown\n\n    return (\n      <Positioner\n        target={({ getRef, isShown, targetWidth }) => {\n          return this.renderTarget({ getRef, isShown, targetWidth })\n        }}\n        isShown={shown}\n        position={position}\n        animationDuration={animationDuration}\n        onOpenComplete={this.handleOpenComplete}\n        onCloseComplete={onCloseComplete}\n      >\n        {({ css, style, state, getRef }) => (\n          <PopoverStateless\n            innerRef={ref => {\n              this.popoverNode = ref\n              getRef(ref)\n            }}\n            data-state={state}\n            display={display}\n            minWidth={minWidth}\n            minHeight={minHeight}\n            {...statelessProps}\n            className={cx(\n              statelessProps.className,\n              css ? glamorCss(css).toString() : undefined\n            )}\n            style={\n              statelessProps && statelessProps.style\n                ? {\n                    ...style,\n                    ...statelessProps.style\n                  }\n                : style\n            }\n            onMouseLeave={this.handleCloseHover}\n          >\n            {typeof content === 'function'\n              ? content({ close: this.close })\n              : content}\n          </PopoverStateless>\n        )}\n      </Positioner>\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"module"}