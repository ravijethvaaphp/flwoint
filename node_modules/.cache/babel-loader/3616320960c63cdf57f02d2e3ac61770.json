{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport Box, { spacing, position, layout, dimensions } from 'ui-box';\nimport safeInvoke from '../../lib/safe-invoke';\nimport SegmentedControlRadio from './SegmentedControlRadio';\nvar radioCount = 1; // Used for generating unique input names\n\nvar SegmentedControl = /*#__PURE__*/function (_PureComponent) {\n  _inherits(SegmentedControl, _PureComponent);\n\n  function SegmentedControl(props, context) {\n    var _this;\n\n    _classCallCheck(this, SegmentedControl);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SegmentedControl).call(this, props, context));\n\n    _defineProperty(_assertThisInitialized(_this), \"isControlled\", function () {\n      return typeof _this.props.value !== 'undefined' && _this.props.value !== null;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleChange\", function (value) {\n      // Save a render cycle when it's a controlled input\n      if (!_this.isControlled()) {\n        _this.setState({\n          value: value\n        });\n      }\n\n      safeInvoke(_this.props.onChange, value);\n    });\n\n    var _value = props.defaultValue;\n\n    if (typeof _value === 'undefined' || _value === null) {\n      _value = props.options[0].value;\n    }\n\n    _this.state = {\n      value: _value\n    };\n    _this.name = \"SegmentedControl-\".concat(radioCount);\n    radioCount += 1;\n    return _this;\n  }\n\n  _createClass(SegmentedControl, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          filterOutValue = _this$props.value,\n          name = _this$props.name,\n          height = _this$props.height,\n          options = _this$props.options,\n          onChange = _this$props.onChange,\n          defaultValue = _this$props.defaultValue,\n          disabled = _this$props.disabled,\n          props = _objectWithoutProperties(_this$props, [\"value\", \"name\", \"height\", \"options\", \"onChange\", \"defaultValue\", \"disabled\"]); // Allows it to behave like a controlled input\n\n\n      var value = this.state.value;\n\n      if (this.isControlled()) {\n        value = this.props.value;\n      }\n\n      return React.createElement(Box, _extends({\n        display: \"flex\",\n        marginRight: -1,\n        height: height\n      }, props), options.map(function (option, index) {\n        return React.createElement(SegmentedControlRadio, {\n          key: option.value,\n          id: _this2.name + index,\n          name: name || _this2.name,\n          label: option.label,\n          value: String(option.value),\n          height: height,\n          checked: value === option.value,\n          onChange: _this2.handleChange.bind(null, option.value),\n          appearance: \"default\",\n          isFirstItem: index === 0,\n          isLastItem: index === options.length - 1,\n          disabled: disabled\n        });\n      }));\n    }\n  }]);\n\n  return SegmentedControl;\n}(PureComponent);\n\nSegmentedControl.displayName = \"SegmentedControl\";\n\n_defineProperty(SegmentedControl, \"propTypes\", _objectSpread({}, spacing.propTypes, {}, position.propTypes, {}, layout.propTypes, {}, dimensions.propTypes, {\n  /**\n   * The options for the radios of the Segmented Control.\n   */\n  options: PropTypes.arrayOf(PropTypes.shape({\n    label: PropTypes.node.isRequired,\n    value: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.bool]).isRequired\n  })).isRequired,\n\n  /**\n   * The current value of the Segmented Control when controlled.\n   */\n  value: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.bool]),\n\n  /**\n   * The default value of the Segmented Control when uncontrolled.\n   */\n  defaultValue: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.bool]),\n\n  /**\n   * Function called when the value changes.\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * The name of the radio group.\n   */\n  name: PropTypes.string,\n\n  /**\n   * The height of the Segmented Control.\n   */\n  height: PropTypes.number,\n\n  /**\n   * When true, the Segmented Control is disabled.\n   */\n  disabled: PropTypes.bool\n}));\n\n_defineProperty(SegmentedControl, \"defaultProps\", {\n  height: 32\n});\n\nexport { SegmentedControl as default };","map":{"version":3,"sources":["../../../src/segmented-control/src/SegmentedControl.js"],"names":["radioCount","SegmentedControl","PureComponent","spacing","propTypes","position","layout","dimensions","options","label","PropTypes","value","isRequired","defaultValue","onChange","func","name","string","height","number","disabled","bool","props","safeInvoke","filterOutValue","option","String","index"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAA,KAAA,IAAA,aAAA,QAAA,OAAA;AACA,OAAA,SAAA,MAAA,YAAA;AACA,OAAA,GAAA,IAAA,OAAA,EAAA,QAAA,EAAA,MAAA,EAAA,UAAA,QAAA,QAAA;AACA,OAAA,UAAA,MAAA,uBAAA;AACA,OAAA,qBAAA,MAAA,yBAAA;AAEA,IAAIA,UAAU,GAAd,CAAA,C,CAAmB;;IAEEC,gB;;;AAmEnB,WAAA,gBAAA,CAAA,KAAA,EAAA,OAAA,EAA4B;AAAA,QAAA,KAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,gBAAA,CAAA;;AAC1B,IAAA,KAAA,GAAA,0BAAA,CAAA,IAAA,EAAA,eAAA,CAAA,gBAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAA,KAAA,EAAA,OAAA,CAAA,CAAA;;AAD0B,IAAA,eAAA,CAAA,sBAAA,CAAA,KAAA,CAAA,EAAA,cAAA,EAgBb,YAAM;AACnB,aAAO,OAAO,KAAA,CAAA,KAAA,CAAP,KAAA,KAAA,WAAA,IAA2C,KAAA,CAAA,KAAA,CAAA,KAAA,KAAlD,IAAA;AAjB0B,KAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,sBAAA,CAAA,KAAA,CAAA,EAAA,cAAA,EAoBb,UAAA,KAAA,EAAS;AACtB;AACA,UAAI,CAAC,KAAA,CAAL,YAAK,EAAL,EAA0B;AACxB,QAAA,KAAA,CAAA,QAAA,CAAc;AAAEU,UAAAA,KAAK,EAALA;AAAF,SAAd;AACD;;AAEDY,MAAAA,UAAU,CAAC,KAAA,CAAA,KAAA,CAAD,QAAA,EAAVA,KAAU,CAAVA;AA1B0B,KAAA,CAAA;;AAG1B,QAAIZ,MAAK,GAAGW,KAAK,CAAjB,YAAA;;AACA,QAAI,OAAA,MAAA,KAAA,WAAA,IAAgCX,MAAK,KAAzC,IAAA,EAAoD;AAClDA,MAAAA,MAAK,GAAGW,KAAK,CAALA,OAAAA,CAAAA,CAAAA,EAARX,KAAAA;AACD;;AAED,IAAA,KAAA,CAAA,KAAA,GAAa;AACXA,MAAAA,KAAK,EAALA;AADW,KAAb;AAIA,IAAA,KAAA,CAAA,IAAA,GAAA,oBAAA,MAAA,CAAA,UAAA,CAAA;AACAX,IAAAA,UAAU,IAAVA,CAAAA;AAb0B,WAAA,KAAA;AAc3B;;;;6BAeQ;AAAA,UAAA,MAAA,GAAA,IAAA;;AAAA,UAAA,WAAA,GAUH,KAVG,KAAA;AAAA,UAEEwB,cAFF,GAAA,WAAA,CAAA,KAAA;AAAA,UAGLR,IAHK,GAAA,WAAA,CAAA,IAAA;AAAA,UAILE,MAJK,GAAA,WAAA,CAAA,MAAA;AAAA,UAKLV,OALK,GAAA,WAAA,CAAA,OAAA;AAAA,UAMLM,QANK,GAAA,WAAA,CAAA,QAAA;AAAA,UAOLD,YAPK,GAAA,WAAA,CAAA,YAAA;AAAA,UAQLO,QARK,GAAA,WAAA,CAAA,QAAA;AAAA,UASFE,KATE,GAAA,wBAAA,CAAA,WAAA,EAAA,CAAA,OAAA,EAAA,MAAA,EAAA,QAAA,EAAA,SAAA,EAAA,UAAA,EAAA,cAAA,EAAA,UAAA,CAAA,CAAA,CAAA,CAYP;;;AAZO,UAaDX,KAbC,GAaS,KAbT,KAaS,CAbT,KAAA;;AAcP,UAAI,KAAJ,YAAI,EAAJ,EAAyB;AACvBA,QAAAA,KAAK,GAAG,KAAA,KAAA,CAARA,KAAAA;AACD;;AAED,aACE,KAAA,CAAA,aAAA,CAAA,GAAA,EAAA,QAAA,CAAA;AAAK,QAAA,OAAO,EAAZ,MAAA;AAAoB,QAAA,WAAW,EAAE,CAAjC,CAAA;AAAqC,QAAA,MAAM,EAAEO;AAA7C,OAAA,EAAA,KAAA,CAAA,EACG,OAAO,CAAP,GAAA,CAAY,UAAA,MAAA,EAAA,KAAA,EAAA;AAAA,eACX,KAAA,CAAA,aAAA,CAAA,qBAAA,EAAA;AACE,UAAA,GAAG,EAAEO,MAAM,CADb,KAAA;AAEE,UAAA,EAAE,EAAE,MAAI,CAAJ,IAAA,GAFN,KAAA;AAGE,UAAA,IAAI,EAAET,IAAI,IAAI,MAAI,CAHpB,IAAA;AAIE,UAAA,KAAK,EAAES,MAAM,CAJf,KAAA;AAKE,UAAA,KAAK,EAAEC,MAAM,CAACD,MAAM,CALtB,KAKe,CALf;AAME,UAAA,MAAM,EANR,MAAA;AAOE,UAAA,OAAO,EAAEd,KAAK,KAAKc,MAAM,CAP3B,KAAA;AAQE,UAAA,QAAQ,EAAE,MAAI,CAAJ,YAAA,CAAA,IAAA,CAAA,IAAA,EAA6BA,MAAM,CAR/C,KAQY,CARZ;AASE,UAAA,UAAU,EATZ,SAAA;AAUE,UAAA,WAAW,EAAEE,KAAK,KAVpB,CAAA;AAWE,UAAA,UAAU,EAAEA,KAAK,KAAKnB,OAAO,CAAPA,MAAAA,GAXxB,CAAA;AAYE,UAAA,QAAQ,EAAEY;AAZZ,SAAA,CADW;AAFjB,OAEK,CADH,CADF;AAoBD;;;;EAtI2ClB,a;;AAAzBD,gB,YAAAA,G,kBAAAA;;gBAAAA,gB,iCAKdE,OAAO,CAACC,S,MACRC,QAAQ,CAACD,S,MACTE,MAAM,CAACF,S,MACPG,UAAU,CAACH,S;AAEd;;;AAGAI,EAAAA,OAAO,EAAE,SAAS,CAAT,OAAA,CACP,SAAS,CAAT,KAAA,CAAgB;AACdC,IAAAA,KAAK,EAAEC,SAAS,CAATA,IAAAA,CADO,UAAA;AAEdC,IAAAA,KAAK,EAAED,SAAS,CAATA,SAAAA,CAAoB,CACzBA,SAAS,CADgB,MAAA,EAEzBA,SAAS,CAFgB,MAAA,EAGzBA,SAAS,CAHJA,IAAoB,CAApBA,EAIJE;AANW,GAAhB,CADO,EASPA,U;;AAEF;;;AAGAD,EAAAA,KAAK,EAAED,SAAS,CAATA,SAAAA,CAAoB,CACzBA,SAAS,CADgB,MAAA,EAEzBA,SAAS,CAFgB,MAAA,EAGzBA,SAAS,CAHJA,IAAoB,CAApBA,C;;AAMP;;;AAGAG,EAAAA,YAAY,EAAEH,SAAS,CAATA,SAAAA,CAAoB,CAChCA,SAAS,CADuB,MAAA,EAEhCA,SAAS,CAFuB,MAAA,EAGhCA,SAAS,CAHGA,IAAoB,CAApBA,C;;AAMd;;;AAGAI,EAAAA,QAAQ,EAAEJ,SAAS,CAACK,I;;AAEpB;;;AAGAC,EAAAA,IAAI,EAAEN,SAAS,CAACO,M;;AAEhB;;;AAGAC,EAAAA,MAAM,EAAER,SAAS,CAACS,M;;AAElB;;;AAGAC,EAAAA,QAAQ,EAAEV,SAAS,CAACW;;;gBA5DHpB,gB,kBA+DG;AACpBiB,EAAAA,MAAM,EAAE;AADY,C;;SA/DHjB,gB","sourcesContent":["import React, { PureComponent } from 'react'\nimport PropTypes from 'prop-types'\nimport Box, { spacing, position, layout, dimensions } from 'ui-box'\nimport safeInvoke from '../../lib/safe-invoke'\nimport SegmentedControlRadio from './SegmentedControlRadio'\n\nlet radioCount = 1 // Used for generating unique input names\n\nexport default class SegmentedControl extends PureComponent {\n  static propTypes = {\n    /**\n     * Composes some Box APIs.\n     */\n    ...spacing.propTypes,\n    ...position.propTypes,\n    ...layout.propTypes,\n    ...dimensions.propTypes,\n\n    /**\n     * The options for the radios of the Segmented Control.\n     */\n    options: PropTypes.arrayOf(\n      PropTypes.shape({\n        label: PropTypes.node.isRequired,\n        value: PropTypes.oneOfType([\n          PropTypes.number,\n          PropTypes.string,\n          PropTypes.bool\n        ]).isRequired\n      })\n    ).isRequired,\n\n    /**\n     * The current value of the Segmented Control when controlled.\n     */\n    value: PropTypes.oneOfType([\n      PropTypes.number,\n      PropTypes.string,\n      PropTypes.bool\n    ]),\n\n    /**\n     * The default value of the Segmented Control when uncontrolled.\n     */\n    defaultValue: PropTypes.oneOfType([\n      PropTypes.number,\n      PropTypes.string,\n      PropTypes.bool\n    ]),\n\n    /**\n     * Function called when the value changes.\n     */\n    onChange: PropTypes.func,\n\n    /**\n     * The name of the radio group.\n     */\n    name: PropTypes.string,\n\n    /**\n     * The height of the Segmented Control.\n     */\n    height: PropTypes.number,\n\n    /**\n     * When true, the Segmented Control is disabled.\n     */\n    disabled: PropTypes.bool\n  }\n\n  static defaultProps = {\n    height: 32\n  }\n\n  constructor(props, context) {\n    super(props, context)\n\n    let value = props.defaultValue\n    if (typeof value === 'undefined' || value === null) {\n      value = props.options[0].value\n    }\n\n    this.state = {\n      value\n    }\n\n    this.name = `SegmentedControl-${radioCount}`\n    radioCount += 1\n  }\n\n  isControlled = () => {\n    return typeof this.props.value !== 'undefined' && this.props.value !== null\n  }\n\n  handleChange = value => {\n    // Save a render cycle when it's a controlled input\n    if (!this.isControlled()) {\n      this.setState({ value })\n    }\n\n    safeInvoke(this.props.onChange, value)\n  }\n\n  render() {\n    const {\n      value: filterOutValue, // Filter out.\n      name,\n      height,\n      options,\n      onChange,\n      defaultValue,\n      disabled,\n      ...props\n    } = this.props\n\n    // Allows it to behave like a controlled input\n    let { value } = this.state\n    if (this.isControlled()) {\n      value = this.props.value\n    }\n\n    return (\n      <Box display=\"flex\" marginRight={-1} height={height} {...props}>\n        {options.map((option, index) => (\n          <SegmentedControlRadio\n            key={option.value}\n            id={this.name + index}\n            name={name || this.name}\n            label={option.label}\n            value={String(option.value)}\n            height={height}\n            checked={value === option.value}\n            onChange={this.handleChange.bind(null, option.value)}\n            appearance=\"default\"\n            isFirstItem={index === 0}\n            isLastItem={index === options.length - 1}\n            disabled={disabled}\n          />\n        ))}\n      </Box>\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"module"}