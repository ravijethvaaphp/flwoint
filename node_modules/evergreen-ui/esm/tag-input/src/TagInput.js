import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _extends from "@babel/runtime/helpers/esm/extends";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

/**
 * @overview TagInput accepts multiple values that can be individually removed
 */
import React from 'react';
import PropTypes from 'prop-types';
import Box from 'ui-box';
import cx from 'classnames';
import { Text } from '../../typography';
import { withTheme } from '../../theme';
import { majorScale } from '../../scales';
import safeInvoke from '../../lib/safe-invoke';
import Tag from './Tag';
var inputId = 1;
var GET_KEY_FOR_TAG_DELIMITER = {
  enter: 'Enter',
  space: ' '
};

var TagInput =
/*#__PURE__*/
function (_React$Component) {
  _inherits(TagInput, _React$Component);

  function TagInput() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, TagInput);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TagInput)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "state", {
      inputValue: '',
      isFocused: false
    });

    _defineProperty(_assertThisInitialized(_this), "id", "TagInput-".concat(inputId++));

    _defineProperty(_assertThisInitialized(_this), "addTags", function () {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var _this$props = _this.props,
          onAdd = _this$props.onAdd,
          onChange = _this$props.onChange,
          values = _this$props.values;

      var newValues = _this.getValues(value);

      var shouldClearInput = safeInvoke(onAdd, newValues);

      if (typeof onChange === 'function') {
        shouldClearInput = shouldClearInput || onChange(values.concat(newValues));
      }

      if (shouldClearInput !== false) {
        _this.setState({
          inputValue: ''
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "getValues", function () {
      var inputValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var separator = _this.props.separator;
      return separator ? inputValue.split(separator).map(function (v) {
        return v.trim();
      }).filter(function (v) {
        return v.length > 0;
      }) : [inputValue];
    });

    _defineProperty(_assertThisInitialized(_this), "handleBackspaceToRemove", function () {
      var values = _this.props.values; // Delete last item in values

      _this.removeTagAtIndex(values.length - 1);
    });

    _defineProperty(_assertThisInitialized(_this), "handleBlur", function (event) {
      var container = event.target; // Use raf so that the dom has time to update `activeElement`

      requestAnimationFrame(function () {
        if (!container.contains(document.activeElement)) {
          if (_this.props.addOnBlur && _this.state.inputValue) {
            _this.addTags(_this.state.inputValue);
          }

          _this.setState({
            isFocused: false
          });
        }
      });
      safeInvoke(_this.props.onBlur, event);
    });

    _defineProperty(_assertThisInitialized(_this), "handleInputChange", function (event) {
      _this.setState({
        inputValue: event.target.value
      });

      safeInvoke(_this.props.onInputChange, event);
    });

    _defineProperty(_assertThisInitialized(_this), "handleInputFocus", function (event) {
      _this.setState({
        isFocused: true
      });

      safeInvoke(_this.props.onFocus, event);
    });

    _defineProperty(_assertThisInitialized(_this), "handleKeyDown", function (event) {
      var _event$target = event.target,
          selectionEnd = _event$target.selectionEnd,
          value = _event$target.value;
      var key = GET_KEY_FOR_TAG_DELIMITER[_this.props.tagSubmitKey];

      if (event.key === key) {
        // Prevent Enter keypresses from submitting forms since they have special powers inside TagInput
        event.preventDefault();

        _this.addTags(value);
      } else if (event.key === 'Backspace' && selectionEnd === 0) {
        _this.handleBackspaceToRemove(event);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleRemoveTag", function (event) {
      // Using data attribute to simplify callback logic -- one handler for all children
      var index = Number(event.currentTarget.parentElement.getAttribute('data-tag-index'));

      _this.removeTagAtIndex(index);
    });

    _defineProperty(_assertThisInitialized(_this), "maybeRenderTag", function (tag, index) {
      if (!tag) {
        return null;
      }

      var _this$props2 = _this.props,
          disabled = _this$props2.disabled,
          tagProps = _this$props2.tagProps;
      var props = safeInvoke(tagProps, tag, index) || tagProps;
      return React.createElement(Tag, _extends({
        key: "".concat(tag, ":").concat(index),
        "data-tag-index": index,
        marginRight: majorScale(1),
        marginY: "6px",
        onRemove: disabled ? null : _this.handleRemoveTag,
        isRemovable: !disabled
      }, props), tag);
    });

    _defineProperty(_assertThisInitialized(_this), "removeTagAtIndex", function (index) {
      var _this$props3 = _this.props,
          onChange = _this$props3.onChange,
          onRemove = _this$props3.onRemove,
          values = _this$props3.values;
      safeInvoke(onRemove, values[index], index); // Remove item at index as a new array

      var newValues = values.filter(function (_, i) {
        return i !== index;
      });
      safeInvoke(onChange, newValues);
    });

    _defineProperty(_assertThisInitialized(_this), "setRef", function (node) {
      _this.input = node;
      safeInvoke(_this.props.inputRef, node);
    });

    return _this;
  }

  _createClass(TagInput, [{
    key: "render",
    value: function render() {
      var _this$props4 = this.props,
          addOnBlur = _this$props4.addOnBlur,
          className = _this$props4.className,
          disabled = _this$props4.disabled,
          height = _this$props4.height,
          inputProps = _this$props4.inputProps,
          inputRef = _this$props4.inputRef,
          onAdd = _this$props4.onAdd,
          onChange = _this$props4.onChange,
          onInputChange = _this$props4.onInputChange,
          onRemove = _this$props4.onRemove,
          separator = _this$props4.separator,
          tagProps = _this$props4.tagProps,
          theme = _this$props4.theme,
          values = _this$props4.values,
          props = _objectWithoutProperties(_this$props4, ["addOnBlur", "className", "disabled", "height", "inputProps", "inputRef", "onAdd", "onChange", "onInputChange", "onRemove", "separator", "tagProps", "theme", "values"]);

      var _this$state = this.state,
          inputValue = _this$state.inputValue,
          isFocused = _this$state.isFocused;
      var themedContainerClassName = theme.getTagInputClassName('default');
      var themedInputClassName = theme.getTextInputClassName('none');
      var textSize = theme.getTextSizeForControlHeight(height);
      var borderRadius = theme.getBorderRadiusForControlHeight(height);
      return React.createElement(Box, _extends({
        "aria-disabled": disabled || undefined,
        "aria-activedescendant": isFocused ? this.id : undefined,
        borderRadius: borderRadius,
        className: cx(themedContainerClassName, className),
        paddingLeft: Math.round(height / 3.2),
        paddingRight: Math.round(height / 3.2),
        paddingY: "2px"
      }, props, {
        onBlur: this.handleBlur
      }), values.map(this.maybeRenderTag), React.createElement(Text, _extends({
        is: "input",
        id: this.id,
        color: disabled ? 'muted' : undefined,
        disabled: disabled,
        flexGrow: "1",
        height: height - 4,
        size: textSize,
        type: "text",
        value: inputValue
      }, inputProps, {
        className: themedInputClassName,
        ref: this.setRef,
        onChange: this.handleInputChange,
        onFocus: this.handleInputFocus,
        onKeyDown: this.handleKeyDown
      })));
    }
  }]);

  return TagInput;
}(React.Component);

TagInput.displayName = "TagInput";

_defineProperty(TagInput, "propTypes", {
  /** Whether or not the inputValue should be added to the tags when the input blurs. */
  addOnBlur: PropTypes.bool,

  /** The class name to apply to the container component. */
  className: PropTypes.string,

  /** Whether or not the input should be disabled. */
  disabled: PropTypes.bool,

  /** The vertical size of the input */
  height: PropTypes.number,

  /** Props to pass to the input component. Note that `ref` and `key` are not supported. See `inputRef`. */
  inputProps: PropTypes.object,

  /**
   * Ref handler for the input element.
   * (input: HTMLInputElement | null) => void
   */
  inputRef: PropTypes.func,

  /**
   * Callback invoked when new tags are added.
   * Returning `false` will prevent clearing the input.
   * (values: Array) => void | false
   */
  onAdd: PropTypes.func,

  /**
   * Callback invoked when focus on the input blurs.
   * (event) => void
   */
  onBlur: PropTypes.func,

  /**
   * Callback invoked when the tag values change.
   * Returning `false` will prevent clearing the input.
   * (values: Array) => void | false
   */
  onChange: PropTypes.func,

  /**
   * Callback invoked when the input receives focus.
   * (event) => void
   */
  onFocus: PropTypes.func,

  /**
   * Callback invoked when the value of the input is changed. Shorthand for `inputProps={{ onChange }}`.
   * (event) => void
   */
  onInputChange: PropTypes.func,

  /**
   * Callback invoked when a tag is removed.
   * Receives value and index of removed tag.
   * (value: string | node, index: number) => void
   */
  onRemove: PropTypes.func,

  /** Value or RegExp to split on pasted text or on enter keypress */
  separator: PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(RegExp), PropTypes.oneOf([false])]),

  /** Provide props to tag component (actually `Badge`, for now). */
  tagProps: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),

  /** Key to press in order to submit a new tag while typing.  */
  tagSubmitKey: PropTypes.oneOf(['enter', 'space']),

  /**
   * Theme provided by ThemeProvider.
   */
  theme: PropTypes.object.isRequired,

  /** Controlled tag values. Each value is rendered inside a tag. */
  values: PropTypes.arrayOf(PropTypes.node)
});

_defineProperty(TagInput, "defaultProps", {
  addOnBlur: false,
  disabled: false,
  height: 32,
  separator: /[,\n\r]/,
  values: [],
  tagSubmitKey: 'enter',
  tagProps: {}
});

export default withTheme(TagInput);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90YWctaW5wdXQvc3JjL1RhZ0lucHV0LmpzIl0sIm5hbWVzIjpbIlJlYWN0IiwiUHJvcFR5cGVzIiwiQm94IiwiY3giLCJUZXh0Iiwid2l0aFRoZW1lIiwibWFqb3JTY2FsZSIsInNhZmVJbnZva2UiLCJUYWciLCJpbnB1dElkIiwiR0VUX0tFWV9GT1JfVEFHX0RFTElNSVRFUiIsImVudGVyIiwic3BhY2UiLCJUYWdJbnB1dCIsImlucHV0VmFsdWUiLCJpc0ZvY3VzZWQiLCJ2YWx1ZSIsInByb3BzIiwib25BZGQiLCJvbkNoYW5nZSIsInZhbHVlcyIsIm5ld1ZhbHVlcyIsImdldFZhbHVlcyIsInNob3VsZENsZWFySW5wdXQiLCJjb25jYXQiLCJzZXRTdGF0ZSIsInNlcGFyYXRvciIsInNwbGl0IiwibWFwIiwidiIsInRyaW0iLCJmaWx0ZXIiLCJsZW5ndGgiLCJyZW1vdmVUYWdBdEluZGV4IiwiZXZlbnQiLCJjb250YWluZXIiLCJ0YXJnZXQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjb250YWlucyIsImRvY3VtZW50IiwiYWN0aXZlRWxlbWVudCIsImFkZE9uQmx1ciIsInN0YXRlIiwiYWRkVGFncyIsIm9uQmx1ciIsIm9uSW5wdXRDaGFuZ2UiLCJvbkZvY3VzIiwic2VsZWN0aW9uRW5kIiwia2V5IiwidGFnU3VibWl0S2V5IiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVCYWNrc3BhY2VUb1JlbW92ZSIsImluZGV4IiwiTnVtYmVyIiwiY3VycmVudFRhcmdldCIsInBhcmVudEVsZW1lbnQiLCJnZXRBdHRyaWJ1dGUiLCJ0YWciLCJkaXNhYmxlZCIsInRhZ1Byb3BzIiwiaGFuZGxlUmVtb3ZlVGFnIiwib25SZW1vdmUiLCJfIiwiaSIsIm5vZGUiLCJpbnB1dCIsImlucHV0UmVmIiwiY2xhc3NOYW1lIiwiaGVpZ2h0IiwiaW5wdXRQcm9wcyIsInRoZW1lIiwidGhlbWVkQ29udGFpbmVyQ2xhc3NOYW1lIiwiZ2V0VGFnSW5wdXRDbGFzc05hbWUiLCJ0aGVtZWRJbnB1dENsYXNzTmFtZSIsImdldFRleHRJbnB1dENsYXNzTmFtZSIsInRleHRTaXplIiwiZ2V0VGV4dFNpemVGb3JDb250cm9sSGVpZ2h0IiwiYm9yZGVyUmFkaXVzIiwiZ2V0Qm9yZGVyUmFkaXVzRm9yQ29udHJvbEhlaWdodCIsInVuZGVmaW5lZCIsImlkIiwiTWF0aCIsInJvdW5kIiwiaGFuZGxlQmx1ciIsIm1heWJlUmVuZGVyVGFnIiwic2V0UmVmIiwiaGFuZGxlSW5wdXRDaGFuZ2UiLCJoYW5kbGVJbnB1dEZvY3VzIiwiaGFuZGxlS2V5RG93biIsIkNvbXBvbmVudCIsImJvb2wiLCJzdHJpbmciLCJudW1iZXIiLCJvYmplY3QiLCJmdW5jIiwib25lT2ZUeXBlIiwiaW5zdGFuY2VPZiIsIlJlZ0V4cCIsIm9uZU9mIiwiaXNSZXF1aXJlZCIsImFycmF5T2YiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7O0FBSUEsT0FBT0EsS0FBUCxNQUFrQixPQUFsQjtBQUNBLE9BQU9DLFNBQVAsTUFBc0IsWUFBdEI7QUFDQSxPQUFPQyxHQUFQLE1BQWdCLFFBQWhCO0FBQ0EsT0FBT0MsRUFBUCxNQUFlLFlBQWY7QUFDQSxTQUFTQyxJQUFULFFBQXFCLGtCQUFyQjtBQUNBLFNBQVNDLFNBQVQsUUFBMEIsYUFBMUI7QUFDQSxTQUFTQyxVQUFULFFBQTJCLGNBQTNCO0FBQ0EsT0FBT0MsVUFBUCxNQUF1Qix1QkFBdkI7QUFDQSxPQUFPQyxHQUFQLE1BQWdCLE9BQWhCO0FBRUEsSUFBSUMsT0FBTyxHQUFHLENBQWQ7QUFFQSxJQUFNQyx5QkFBeUIsR0FBRztBQUNoQ0MsRUFBQUEsS0FBSyxFQUFFLE9BRHlCO0FBRWhDQyxFQUFBQSxLQUFLLEVBQUU7QUFGeUIsQ0FBbEM7O0lBS01DLFE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0REE4RUk7QUFDTkMsTUFBQUEsVUFBVSxFQUFFLEVBRE47QUFFTkMsTUFBQUEsU0FBUyxFQUFFO0FBRkwsSzs7NEVBS1NOLE9BQU8sRTs7OERBRWQsWUFB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QUFBLE1BQU0sRUFBRSxFQUhZO0FBSXBCMUMsRUFBQUEsU0FBUyxFQUFFLFNBSlM7QUFLcEJOLEVBQUFBLE1BQU0sRUFBRSxFQUxZO0FBTXBCNkIsRUFBQUEsWUFBWSxFQUFFLE9BTk07QUFPcEJVLEVBQUFBLFFBQVEsRUFBRTtBQVBVLEM7O0FBb014QixlQUFldEQsU0FBUyxDQUFDUSxRQUFELENBQXhCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAb3ZlcnZpZXcgVGFnSW5wdXQgYWNjZXB0cyBtdWx0aXBsZSB2YWx1ZXMgdGhhdCBjYW4gYmUgaW5kaXZpZHVhbGx5IHJlbW92ZWRcbiAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgQm94IGZyb20gJ3VpLWJveCdcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJ1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uLy4uL3R5cG9ncmFwaHknXG5pbXBvcnQgeyB3aXRoVGhlbWUgfSBmcm9tICcuLi8uLi90aGVtZSdcbmltcG9ydCB7IG1ham9yU2NhbGUgfSBmcm9tICcuLi8uLi9zY2FsZXMnXG5pbXBvcnQgc2FmZUludm9rZSBmcm9tICcuLi8uLi9saWIvc2FmZS1pbnZva2UnXG5pbXBvcnQgVGFnIGZyb20gJy4vVGFnJ1xuXG5sZXQgaW5wdXRJZCA9IDFcblxuY29uc3QgR0VUX0tFWV9GT1JfVEFHX0RFTElNSVRFUiA9IHtcbiAgZW50ZXI6ICdFbnRlcicsXG4gIHNwYWNlOiAnICdcbn1cblxuY2xhc3MgVGFnSW5wdXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgaW5wdXRWYWx1ZSBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIHRhZ3Mgd2hlbiB0aGUgaW5wdXQgYmx1cnMuICovXG4gICAgYWRkT25CbHVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAvKiogVGhlIGNsYXNzIG5hbWUgdG8gYXBwbHkgdG8gdGhlIGNvbnRhaW5lciBjb21wb25lbnQuICovXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgaW5wdXQgc2hvdWxkIGJlIGRpc2FibGVkLiAqL1xuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICAvKiogVGhlIHZlcnRpY2FsIHNpemUgb2YgdGhlIGlucHV0ICovXG4gICAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIC8qKiBQcm9wcyB0byBwYXNzIHRvIHRoZSBpbnB1dCBjb21wb25lbnQuIE5vdGUgdGhhdCBgcmVmYCBhbmQgYGtleWAgYXJlIG5vdCBzdXBwb3J0ZWQuIFNlZSBgaW5wdXRSZWZgLiAqL1xuICAgIGlucHV0UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgLyoqXG4gICAgICogUmVmIGhhbmRsZXIgZm9yIHRoZSBpbnB1dCBlbGVtZW50LlxuICAgICAqIChpbnB1dDogSFRNTElucHV0RWxlbWVudCB8IG51bGwpID0+IHZvaWRcbiAgICAgKi9cbiAgICBpbnB1dFJlZjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgaW52b2tlZCB3aGVuIG5ldyB0YWdzIGFyZSBhZGRlZC5cbiAgICAgKiBSZXR1cm5pbmcgYGZhbHNlYCB3aWxsIHByZXZlbnQgY2xlYXJpbmcgdGhlIGlucHV0LlxuICAgICAqICh2YWx1ZXM6IEFycmF5KSA9PiB2b2lkIHwgZmFsc2VcbiAgICAgKi9cbiAgICBvbkFkZDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgaW52b2tlZCB3aGVuIGZvY3VzIG9uIHRoZSBpbnB1dCBibHVycy5cbiAgICAgKiAoZXZlbnQpID0+IHZvaWRcbiAgICAgKi9cbiAgICBvbkJsdXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIGludm9rZWQgd2hlbiB0aGUgdGFnIHZhbHVlcyBjaGFuZ2UuXG4gICAgICogUmV0dXJuaW5nIGBmYWxzZWAgd2lsbCBwcmV2ZW50IGNsZWFyaW5nIHRoZSBpbnB1dC5cbiAgICAgKiAodmFsdWVzOiBBcnJheSkgPT4gdm9pZCB8IGZhbHNlXG4gICAgICovXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIGludm9rZWQgd2hlbiB0aGUgaW5wdXQgcmVjZWl2ZXMgZm9jdXMuXG4gICAgICogKGV2ZW50KSA9PiB2b2lkXG4gICAgICovXG4gICAgb25Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgaW52b2tlZCB3aGVuIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgaXMgY2hhbmdlZC4gU2hvcnRoYW5kIGZvciBgaW5wdXRQcm9wcz17eyBvbkNoYW5nZSB9fWAuXG4gICAgICogKGV2ZW50KSA9PiB2b2lkXG4gICAgICovXG4gICAgb25JbnB1dENoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgaW52b2tlZCB3aGVuIGEgdGFnIGlzIHJlbW92ZWQuXG4gICAgICogUmVjZWl2ZXMgdmFsdWUgYW5kIGluZGV4IG9mIHJlbW92ZWQgdGFnLlxuICAgICAqICh2YWx1ZTogc3RyaW5nIHwgbm9kZSwgaW5kZXg6IG51bWJlcikgPT4gdm9pZFxuICAgICAqL1xuICAgIG9uUmVtb3ZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICAvKiogVmFsdWUgb3IgUmVnRXhwIHRvIHNwbGl0IG9uIHBhc3RlZCB0ZXh0IG9yIG9uIGVudGVyIGtleXByZXNzICovXG4gICAgc2VwYXJhdG9yOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgIFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICBQcm9wVHlwZXMuaW5zdGFuY2VPZihSZWdFeHApLFxuICAgICAgUHJvcFR5cGVzLm9uZU9mKFtmYWxzZV0pXG4gICAgXSksXG4gICAgLyoqIFByb3ZpZGUgcHJvcHMgdG8gdGFnIGNvbXBvbmVudCAoYWN0dWFsbHkgYEJhZGdlYCwgZm9yIG5vdykuICovXG4gICAgdGFnUHJvcHM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgLyoqIEtleSB0byBwcmVzcyBpbiBvcmRlciB0byBzdWJtaXQgYSBuZXcgdGFnIHdoaWxlIHR5cGluZy4gICovXG4gICAgdGFnU3VibWl0S2V5OiBQcm9wVHlwZXMub25lT2YoWydlbnRlcicsICdzcGFjZSddKSxcbiAgICAvKipcbiAgICAgKiBUaGVtZSBwcm92aWRlZCBieSBUaGVtZVByb3ZpZGVyLlxuICAgICAqL1xuICAgIHRoZW1lOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgLyoqIENvbnRyb2xsZWQgdGFnIHZhbHVlcy4gRWFjaCB2YWx1ZSBpcyByZW5kZXJlZCBpbnNpZGUgYSB0YWcuICovXG4gICAgdmFsdWVzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubm9kZSlcbiAgfVxuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgYWRkT25CbHVyOiBmYWxzZSxcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgaGVpZ2h0OiAzMixcbiAgICBzZXBhcmF0b3I6IC9bLFxcblxccl0vLFxuICAgIHZhbHVlczogW10sXG4gICAgdGFnU3VibWl0S2V5OiAnZW50ZXInLFxuICAgIHRhZ1Byb3BzOiB7fVxuICB9XG5cbiAgc3RhdGUgPSB7XG4gICAgaW5wdXRWYWx1ZTogJycsXG4gICAgaXNGb2N1c2VkOiBmYWxzZVxuICB9XG5cbiAgaWQgPSBgVGFnSW5wdXQtJHtpbnB1dElkKyt9YFxuXG4gIGFkZFRhZ3MgPSAodmFsdWUgPSAnJykgPT4ge1xuICAgIGNvbnN0IHsgb25BZGQsIG9uQ2hhbmdlLCB2YWx1ZXMgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCBuZXdWYWx1ZXMgPSB0aGlzLmdldFZhbHVlcyh2YWx1ZSlcbiAgICBsZXQgc2hvdWxkQ2xlYXJJbnB1dCA9IHNhZmVJbnZva2Uob25BZGQsIG5ld1ZhbHVlcylcblxuICAgIGlmICh0eXBlb2Ygb25DaGFuZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNob3VsZENsZWFySW5wdXQgPSBzaG91bGRDbGVhcklucHV0IHx8IG9uQ2hhbmdlKHZhbHVlcy5jb25jYXQobmV3VmFsdWVzKSlcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkQ2xlYXJJbnB1dCAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBpbnB1dFZhbHVlOiAnJyB9KVxuICAgIH1cbiAgfVxuXG4gIGdldFZhbHVlcyA9IChpbnB1dFZhbHVlID0gJycpID0+IHtcbiAgICBjb25zdCB7IHNlcGFyYXRvciB9ID0gdGhpcy5wcm9wc1xuXG4gICAgcmV0dXJuIHNlcGFyYXRvclxuICAgICAgPyBpbnB1dFZhbHVlXG4gICAgICAgICAgLnNwbGl0KHNlcGFyYXRvcilcbiAgICAgICAgICAubWFwKHYgPT4gdi50cmltKCkpXG4gICAgICAgICAgLmZpbHRlcih2ID0+IHYubGVuZ3RoID4gMClcbiAgICAgIDogW2lucHV0VmFsdWVdXG4gIH1cblxuICBoYW5kbGVCYWNrc3BhY2VUb1JlbW92ZSA9ICgpID0+IHtcbiAgICBjb25zdCB7IHZhbHVlcyB9ID0gdGhpcy5wcm9wc1xuXG4gICAgLy8gRGVsZXRlIGxhc3QgaXRlbSBpbiB2YWx1ZXNcbiAgICB0aGlzLnJlbW92ZVRhZ0F0SW5kZXgodmFsdWVzLmxlbmd0aCAtIDEpXG4gIH1cblxuICBoYW5kbGVCbHVyID0gZXZlbnQgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGV2ZW50LnRhcmdldFxuXG4gICAgLy8gVXNlIHJhZiBzbyB0aGF0IHRoZSBkb20gaGFzIHRpbWUgdG8gdXBkYXRlIGBhY3RpdmVFbGVtZW50YFxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBpZiAoIWNvbnRhaW5lci5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5hZGRPbkJsdXIgJiYgdGhpcy5zdGF0ZS5pbnB1dFZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5hZGRUYWdzKHRoaXMuc3RhdGUuaW5wdXRWYWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc0ZvY3VzZWQ6IGZhbHNlIH0pXG4gICAgICB9XG4gICAgfSlcblxuICAgIHNhZmVJbnZva2UodGhpcy5wcm9wcy5vbkJsdXIsIGV2ZW50KVxuICB9XG5cbiAgaGFuZGxlSW5wdXRDaGFuZ2UgPSBldmVudCA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGlucHV0VmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZSB9KVxuICAgIHNhZmVJbnZva2UodGhpcy5wcm9wcy5vbklucHV0Q2hhbmdlLCBldmVudClcbiAgfVxuXG4gIGhhbmRsZUlucHV0Rm9jdXMgPSBldmVudCA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGlzRm9jdXNlZDogdHJ1ZSB9KVxuICAgIHNhZmVJbnZva2UodGhpcy5wcm9wcy5vbkZvY3VzLCBldmVudClcbiAgfVxuXG4gIGhhbmRsZUtleURvd24gPSBldmVudCA9PiB7XG4gICAgY29uc3QgeyBzZWxlY3Rpb25FbmQsIHZhbHVlIH0gPSBldmVudC50YXJnZXRcblxuICAgIGNvbnN0IGtleSA9IEdFVF9LRVlfRk9SX1RBR19ERUxJTUlURVJbdGhpcy5wcm9wcy50YWdTdWJtaXRLZXldXG5cbiAgICBpZiAoZXZlbnQua2V5ID09PSBrZXkpIHtcbiAgICAgIC8vIFByZXZlbnQgRW50ZXIga2V5cHJlc3NlcyBmcm9tIHN1Ym1pdHRpbmcgZm9ybXMgc2luY2UgdGhleSBoYXZlIHNwZWNpYWwgcG93ZXJzIGluc2lkZSBUYWdJbnB1dFxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgdGhpcy5hZGRUYWdzKHZhbHVlKVxuICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSAnQmFja3NwYWNlJyAmJiBzZWxlY3Rpb25FbmQgPT09IDApIHtcbiAgICAgIHRoaXMuaGFuZGxlQmFja3NwYWNlVG9SZW1vdmUoZXZlbnQpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlUmVtb3ZlVGFnID0gZXZlbnQgPT4ge1xuICAgIC8vIFVzaW5nIGRhdGEgYXR0cmlidXRlIHRvIHNpbXBsaWZ5IGNhbGxiYWNrIGxvZ2ljIC0tIG9uZSBoYW5kbGVyIGZvciBhbGwgY2hpbGRyZW5cbiAgICBjb25zdCBpbmRleCA9IE51bWJlcihcbiAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQucGFyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFnLWluZGV4JylcbiAgICApXG4gICAgdGhpcy5yZW1vdmVUYWdBdEluZGV4KGluZGV4KVxuICB9XG5cbiAgbWF5YmVSZW5kZXJUYWcgPSAodGFnLCBpbmRleCkgPT4ge1xuICAgIGlmICghdGFnKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IHsgZGlzYWJsZWQsIHRhZ1Byb3BzIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgcHJvcHMgPSBzYWZlSW52b2tlKHRhZ1Byb3BzLCB0YWcsIGluZGV4KSB8fCB0YWdQcm9wc1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxUYWdcbiAgICAgICAga2V5PXtgJHt0YWd9OiR7aW5kZXh9YH1cbiAgICAgICAgZGF0YS10YWctaW5kZXg9e2luZGV4fVxuICAgICAgICBtYXJnaW5SaWdodD17bWFqb3JTY2FsZSgxKX1cbiAgICAgICAgbWFyZ2luWT1cIjZweFwiXG4gICAgICAgIG9uUmVtb3ZlPXtkaXNhYmxlZCA/IG51bGwgOiB0aGlzLmhhbmRsZVJlbW92ZVRhZ31cbiAgICAgICAgaXNSZW1vdmFibGU9eyFkaXNhYmxlZH1cbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgPlxuICAgICAgICB7dGFnfVxuICAgICAgPC9UYWc+XG4gICAgKVxuICB9XG5cbiAgcmVtb3ZlVGFnQXRJbmRleCA9IGluZGV4ID0+IHtcbiAgICBjb25zdCB7IG9uQ2hhbmdlLCBvblJlbW92ZSwgdmFsdWVzIH0gPSB0aGlzLnByb3BzXG4gICAgc2FmZUludm9rZShvblJlbW92ZSwgdmFsdWVzW2luZGV4XSwgaW5kZXgpXG5cbiAgICAvLyBSZW1vdmUgaXRlbSBhdCBpbmRleCBhcyBhIG5ldyBhcnJheVxuICAgIGNvbnN0IG5ld1ZhbHVlcyA9IHZhbHVlcy5maWx0ZXIoKF8sIGkpID0+IGkgIT09IGluZGV4KVxuICAgIHNhZmVJbnZva2Uob25DaGFuZ2UsIG5ld1ZhbHVlcylcbiAgfVxuXG4gIHNldFJlZiA9IG5vZGUgPT4ge1xuICAgIHRoaXMuaW5wdXQgPSBub2RlXG4gICAgc2FmZUludm9rZSh0aGlzLnByb3BzLmlucHV0UmVmLCBub2RlKVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFkZE9uQmx1cixcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIGRpc2FibGVkLFxuICAgICAgaGVpZ2h0LFxuICAgICAgaW5wdXRQcm9wcyxcbiAgICAgIGlucHV0UmVmLFxuICAgICAgb25BZGQsXG4gICAgICBvbkNoYW5nZSxcbiAgICAgIG9uSW5wdXRDaGFuZ2UsXG4gICAgICBvblJlbW92ZSxcbiAgICAgIHNlcGFyYXRvcixcbiAgICAgIHRhZ1Byb3BzLFxuICAgICAgdGhlbWUsXG4gICAgICB2YWx1ZXMsXG4gICAgICAuLi5wcm9wc1xuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICBjb25zdCB7IGlucHV0VmFsdWUsIGlzRm9jdXNlZCB9ID0gdGhpcy5zdGF0ZVxuXG4gICAgY29uc3QgdGhlbWVkQ29udGFpbmVyQ2xhc3NOYW1lID0gdGhlbWUuZ2V0VGFnSW5wdXRDbGFzc05hbWUoJ2RlZmF1bHQnKVxuICAgIGNvbnN0IHRoZW1lZElucHV0Q2xhc3NOYW1lID0gdGhlbWUuZ2V0VGV4dElucHV0Q2xhc3NOYW1lKCdub25lJylcbiAgICBjb25zdCB0ZXh0U2l6ZSA9IHRoZW1lLmdldFRleHRTaXplRm9yQ29udHJvbEhlaWdodChoZWlnaHQpXG4gICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdGhlbWUuZ2V0Qm9yZGVyUmFkaXVzRm9yQ29udHJvbEhlaWdodChoZWlnaHQpXG5cbiAgICByZXR1cm4gKFxuICAgICAgPEJveFxuICAgICAgICBhcmlhLWRpc2FibGVkPXtkaXNhYmxlZCB8fCB1bmRlZmluZWR9XG4gICAgICAgIGFyaWEtYWN0aXZlZGVzY2VuZGFudD17aXNGb2N1c2VkID8gdGhpcy5pZCA6IHVuZGVmaW5lZH1cbiAgICAgICAgYm9yZGVyUmFkaXVzPXtib3JkZXJSYWRpdXN9XG4gICAgICAgIGNsYXNzTmFtZT17Y3godGhlbWVkQ29udGFpbmVyQ2xhc3NOYW1lLCBjbGFzc05hbWUpfVxuICAgICAgICBwYWRkaW5nTGVmdD17TWF0aC5yb3VuZChoZWlnaHQgLyAzLjIpfVxuICAgICAgICBwYWRkaW5nUmlnaHQ9e01hdGgucm91bmQoaGVpZ2h0IC8gMy4yKX1cbiAgICAgICAgcGFkZGluZ1k9XCIycHhcIlxuICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgIG9uQmx1cj17dGhpcy5oYW5kbGVCbHVyfVxuICAgICAgPlxuICAgICAgICB7dmFsdWVzLm1hcCh0aGlzLm1heWJlUmVuZGVyVGFnKX1cbiAgICAgICAgPFRleHRcbiAgICAgICAgICBpcz1cImlucHV0XCJcbiAgICAgICAgICBpZD17dGhpcy5pZH1cbiAgICAgICAgICBjb2xvcj17ZGlzYWJsZWQgPyAnbXV0ZWQnIDogdW5kZWZpbmVkfVxuICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICBmbGV4R3Jvdz1cIjFcIlxuICAgICAgICAgIGhlaWdodD17aGVpZ2h0IC0gNH1cbiAgICAgICAgICBzaXplPXt0ZXh0U2l6ZX1cbiAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgdmFsdWU9e2lucHV0VmFsdWV9XG4gICAgICAgICAgey4uLmlucHV0UHJvcHN9XG4gICAgICAgICAgY2xhc3NOYW1lPXt0aGVtZWRJbnB1dENsYXNzTmFtZX1cbiAgICAgICAgICByZWY9e3RoaXMuc2V0UmVmfVxuICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmhhbmRsZUlucHV0Q2hhbmdlfVxuICAgICAgICAgIG9uRm9jdXM9e3RoaXMuaGFuZGxlSW5wdXRGb2N1c31cbiAgICAgICAgICBvbktleURvd249e3RoaXMuaGFuZGxlS2V5RG93bn1cbiAgICAgICAgLz5cbiAgICAgIDwvQm94PlxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoVGhlbWUoVGFnSW5wdXQpXG4iXX0=