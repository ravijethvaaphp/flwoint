import _extends from "@babel/runtime/helpers/esm/extends";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React, { forwardRef } from 'react';
import PropTypes from 'prop-types';
import Box from 'ui-box';
import { useTheme } from '../../theme';
/**
 * This implementation is a remix of the Icon component in Blueprintjs:
 * https://github.com/palantir/blueprint/blob/813e93f2/packages/core/src/components/icon/icon.tsx#L15
 * Refer to the LICENSE for BlueprintJS here: https://github.com/palantir/blueprint/blob/develop/LICENSE
 */

var TreeShakeableIcon = forwardRef(function (_ref, ref) {
  var _ref$color = _ref.color,
      color = _ref$color === void 0 ? 'currentColor' : _ref$color,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? 16 : _ref$size,
      name = _ref.name,
      title = _ref.title,
      _ref$style = _ref.style,
      style = _ref$style === void 0 ? {} : _ref$style,
      svgPaths16 = _ref.svgPaths16,
      svgPaths20 = _ref.svgPaths20,
      svgProps = _objectWithoutProperties(_ref, ["color", "size", "name", "title", "style", "svgPaths16", "svgPaths20"]);

  var theme = useTheme();
  var SIZE_STANDARD = 16;
  var SIZE_LARGE = 20; // Choose which pixel grid is most appropriate for given icon size

  var pixelGridSize = size >= SIZE_LARGE ? SIZE_LARGE : SIZE_STANDARD;
  var pathStrings = pixelGridSize === SIZE_STANDARD ? svgPaths16 : svgPaths20;
  var paths = pathStrings.map(function (d, i) {
    return (// eslint-disable-next-line react/no-array-index-key
      React.createElement("path", {
        key: i,
        d: d,
        fillRule: "evenodd"
      })
    );
  });
  var viewBox = "0 0 ".concat(pixelGridSize, " ").concat(pixelGridSize);

  if (color) {
    style = _objectSpread({}, style, {
      fill: theme.getIconColor(color)
    });
  }

  return React.createElement(Box, _extends({
    is: "svg" // To allow innerRef to be passed from the consumer this needs to be before svgProps
    ,
    innerRef: ref
  }, svgProps, {
    "data-icon": name,
    style: style,
    width: size,
    height: size,
    viewBox: viewBox
  }), title && React.createElement("title", null, title), paths);
});
TreeShakeableIcon.propTypes = {
  /**
   * Color of icon. Equivalent to setting CSS `fill` property.
   */
  color: PropTypes.string,

  /**
   * Size of the icon, in pixels.
   * Blueprint contains 16px and 20px SVG icon images,
   * and chooses the appropriate resolution based on this prop.
   */
  size: PropTypes.number,

  /**
   * Name of the icon
   */
  name: PropTypes.string,

  /**
   * Description string.
   * Browsers usually render this as a tooltip on hover, whereas screen
   * readers will use it for aural feedback.
   * By default, this is set to the icon's name for accessibility.
   */
  title: PropTypes.string,

  /**
   * CSS style properties.
   */
  style: PropTypes.object,
  svgPaths16: PropTypes.arrayOf(PropTypes.string).isRequired,
  svgPaths20: PropTypes.arrayOf(PropTypes.string).isRequired
};
export default TreeShakeableIcon;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9pY29ucy9zcmMvSWNvbi5qcyJdLCJuYW1lcyI6WyJSZWFjdCIsImZvcndhcmRSZWYiLCJQcm9wVHlwZXMiLCJCb3giLCJ1c2VUaGVtZSIsIlRyZWVTaGFrZWFibGVJY29uIiwicmVmIiwiY29sb3IiLCJzaXplIiwibmFtZSIsInRpdGxlIiwic3R5bGUiLCJzdmdQYXRoczE2Iiwic3ZnUGF0aHMyMCIsInN2Z1Byb3BzIiwidGhlbWUiLCJTSVpFX1NUQU5EQVJEIiwiU0laRV9MQVJHRSIsInBpeGVsR3JpZFNpemUiLCJwYXRoU3RyaW5ncyIsInBhdGhzIiwibWFwIiwiZCIsImkiLCJ2aWV3Qm94IiwiZmlsbCIsImdldEljb25Db2xvciIsInByb3BUeXBlcyIsInN0cmluZyIsIm51bWJlciIsIm9iamVjdCIsImFycmF5T2YiLCJpc1JlcXVpcmVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLE9BQU9BLEtBQVAsSUFBZ0JDLFVBQWhCLFFBQWtDLE9BQWxDO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixZQUF0QjtBQUNBLE9BQU9DLEdBQVAsTUFBZ0IsUUFBaEI7QUFDQSxTQUFTQyxRQUFULFFBQXlCLGFBQXpCO0FBRUE7Ozs7OztBQU1BLElBQU1DLGlCQUFpQixHQUFHSixVQUFVLENBQ2xDLGdCQVdFSyxHQVhGLEVBWUs7QUFBQSx3QkFWREMsS0FVQztBQUFBLE1BVkRBLEtBVUMsMkJBVk8sY0FVUDtBQUFBLHVCQVREQyxJQVNDO0FBQUEsTUFUREEsSUFTQywwQkFUTSxFQVNOO0FBQUEsTUFSREMsSUFRQyxRQVJEQSxJQVFDO0FBQUEsTUFQREMsS0FPQyxRQVBEQSxLQU9DO0FBQUEsd0JBTkRDLEtBTUM7QUFBQSxNQU5EQSxLQU1DLDJCQU5PLEVBTVA7QUFBQSxNQUxEQyxVQUtDLFFBTERBLFVBS0M7QUFBQSxNQUpEQyxVQUlDLFFBSkRBLFVBSUM7QUFBQSxNQUhFQyxRQUdGOztBQUNILE1BQU1DLEtBQUssR0FBR1gsUUFBUSxFQUF0QjtBQUNBLE1BQU1ZLGFBQWEsR0FBRyxFQUF0QjtBQUNBLE1BQU1DLFVBQVUsR0FBRyxFQUFuQixDQUhHLENBS0g7O0FBQ0EsTUFBTUMsYUFBYSxHQUFHVixJQUFJLElBQUlTLFVBQVIsR0FBcUJBLFVBQXJCLEdBQWtDRCxhQUF4RDtBQUNBLE1BQU1HLFdBQVcsR0FDZkQsYUFBYSxLQUFLRixhQUFsQixHQUFrQ0osVUFBbEMsR0FBK0NDLFVBRGpEO0FBRUEsTUFBTU8sS0FBSyxHQUFHRCxXQUFXLENBQUNFLEdBQVosQ0FBZ0IsVUFBQ0MsQ0FBRCxFQUFJQyxDQUFKO0FBQUEsV0FDNUI7QUFDQTtBQUFNLFFBQUEsR0FBRyxFQUFFQSxDQUFYO0FBQWMsUUFBQSxDQUFDLEVBQUVELENBQWpCO0FBQW9CLFFBQUEsUUFBUSxFQUFDO0FBQTdCO0FBRjRCO0FBQUEsR0FBaEIsQ0FBZDtBQUtBLE1BQU1FLE9BQU8saUJBQVVOLGFBQVYsY0FBMkJBLGFBQTNCLENBQWI7O0FBRUEsTUFBSVgsS0FBSixFQUFXO0FBQ1RJLElBQUFBLEtBQUsscUJBQVFBLEtBQVI7QUFBZWMsTUFBQUEsSUFBSSxFQUFFVixLQUFLLENBQUNXLFlBQU4sQ0FBbUJuQixLQUFuQjtBQUFyQixNQUFMO0FBQ0Q7O0FBRUQsU0FDRSxvQkFBQyxHQUFEO0FBQ0UsSUFBQSxFQUFFLEVBQUMsS0FETCxDQUVFO0FBRkY7QUFHRSxJQUFBLFFBQVEsRUFBRUQ7QUFIWixLQUlNUSxRQUpOO0FBS0UsaUJBQVdMLElBTGI7QUFNRSxJQUFBLEtBQUssRUFBRUUsS0FOVDtBQU9FLElBQUEsS0FBSyxFQUFFSCxJQVBUO0FBUUUsSUFBQSxNQUFNLEVBQUVBLElBUlY7QUFTRSxJQUFBLE9BQU8sRUFBRWdCO0FBVFgsTUFXR2QsS0FBSyxJQUFJLG1DQUFRQSxLQUFSLENBWFosRUFZR1UsS0FaSCxDQURGO0FBZ0JELENBakRpQyxDQUFwQztBQW9EQWYsaUJBQWlCLENBQUNzQixTQUFsQixHQUE4QjtBQUM1Qjs7O0FBR0FwQixFQUFBQSxLQUFLLEVBQUVMLFNBQVMsQ0FBQzBCLE1BSlc7O0FBTTVCOzs7OztBQUtBcEIsRUFBQUEsSUFBSSxFQUFFTixTQUFTLENBQUMyQixNQVhZOztBQWE1Qjs7O0FBR0FwQixFQUFBQSxJQUFJLEVBQUVQLFNBQVMsQ0FBQzBCLE1BaEJZOztBQWtCNUI7Ozs7OztBQU1BbEIsRUFBQUEsS0FBSyxFQUFFUixTQUFTLENBQUMwQixNQXhCVzs7QUEwQjVCOzs7QUFHQWpCLEVBQUFBLEtBQUssRUFBRVQsU0FBUyxDQUFDNEIsTUE3Qlc7QUErQjVCbEIsRUFBQUEsVUFBVSxFQUFFVixTQUFTLENBQUM2QixPQUFWLENBQWtCN0IsU0FBUyxDQUFDMEIsTUFBNUIsRUFBb0NJLFVBL0JwQjtBQWlDNUJuQixFQUFBQSxVQUFVLEVBQUVYLFNBQVMsQ0FBQzZCLE9BQVYsQ0FBa0I3QixTQUFTLENBQUMwQixNQUE1QixFQUFvQ0k7QUFqQ3BCLENBQTlCO0FBb0NBLGVBQWUzQixpQkFBZiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgQm94IGZyb20gJ3VpLWJveCdcbmltcG9ydCB7IHVzZVRoZW1lIH0gZnJvbSAnLi4vLi4vdGhlbWUnXG5cbi8qKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBhIHJlbWl4IG9mIHRoZSBJY29uIGNvbXBvbmVudCBpbiBCbHVlcHJpbnRqczpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxhbnRpci9ibHVlcHJpbnQvYmxvYi84MTNlOTNmMi9wYWNrYWdlcy9jb3JlL3NyYy9jb21wb25lbnRzL2ljb24vaWNvbi50c3gjTDE1XG4gKiBSZWZlciB0byB0aGUgTElDRU5TRSBmb3IgQmx1ZXByaW50SlMgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3BhbGFudGlyL2JsdWVwcmludC9ibG9iL2RldmVsb3AvTElDRU5TRVxuICovXG5cbmNvbnN0IFRyZWVTaGFrZWFibGVJY29uID0gZm9yd2FyZFJlZihcbiAgKFxuICAgIHtcbiAgICAgIGNvbG9yID0gJ2N1cnJlbnRDb2xvcicsXG4gICAgICBzaXplID0gMTYsXG4gICAgICBuYW1lLFxuICAgICAgdGl0bGUsXG4gICAgICBzdHlsZSA9IHt9LFxuICAgICAgc3ZnUGF0aHMxNixcbiAgICAgIHN2Z1BhdGhzMjAsXG4gICAgICAuLi5zdmdQcm9wc1xuICAgIH0sXG4gICAgcmVmXG4gICkgPT4ge1xuICAgIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKVxuICAgIGNvbnN0IFNJWkVfU1RBTkRBUkQgPSAxNlxuICAgIGNvbnN0IFNJWkVfTEFSR0UgPSAyMFxuXG4gICAgLy8gQ2hvb3NlIHdoaWNoIHBpeGVsIGdyaWQgaXMgbW9zdCBhcHByb3ByaWF0ZSBmb3IgZ2l2ZW4gaWNvbiBzaXplXG4gICAgY29uc3QgcGl4ZWxHcmlkU2l6ZSA9IHNpemUgPj0gU0laRV9MQVJHRSA/IFNJWkVfTEFSR0UgOiBTSVpFX1NUQU5EQVJEXG4gICAgY29uc3QgcGF0aFN0cmluZ3MgPVxuICAgICAgcGl4ZWxHcmlkU2l6ZSA9PT0gU0laRV9TVEFOREFSRCA/IHN2Z1BhdGhzMTYgOiBzdmdQYXRoczIwXG4gICAgY29uc3QgcGF0aHMgPSBwYXRoU3RyaW5ncy5tYXAoKGQsIGkpID0+IChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1hcnJheS1pbmRleC1rZXlcbiAgICAgIDxwYXRoIGtleT17aX0gZD17ZH0gZmlsbFJ1bGU9XCJldmVub2RkXCIgLz5cbiAgICApKVxuXG4gICAgY29uc3Qgdmlld0JveCA9IGAwIDAgJHtwaXhlbEdyaWRTaXplfSAke3BpeGVsR3JpZFNpemV9YFxuXG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBzdHlsZSA9IHsgLi4uc3R5bGUsIGZpbGw6IHRoZW1lLmdldEljb25Db2xvcihjb2xvcikgfVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8Qm94XG4gICAgICAgIGlzPVwic3ZnXCJcbiAgICAgICAgLy8gVG8gYWxsb3cgaW5uZXJSZWYgdG8gYmUgcGFzc2VkIGZyb20gdGhlIGNvbnN1bWVyIHRoaXMgbmVlZHMgdG8gYmUgYmVmb3JlIHN2Z1Byb3BzXG4gICAgICAgIGlubmVyUmVmPXtyZWZ9XG4gICAgICAgIHsuLi5zdmdQcm9wc31cbiAgICAgICAgZGF0YS1pY29uPXtuYW1lfVxuICAgICAgICBzdHlsZT17c3R5bGV9XG4gICAgICAgIHdpZHRoPXtzaXplfVxuICAgICAgICBoZWlnaHQ9e3NpemV9XG4gICAgICAgIHZpZXdCb3g9e3ZpZXdCb3h9XG4gICAgICA+XG4gICAgICAgIHt0aXRsZSAmJiA8dGl0bGU+e3RpdGxlfTwvdGl0bGU+fVxuICAgICAgICB7cGF0aHN9XG4gICAgICA8L0JveD5cbiAgICApXG4gIH1cbilcblxuVHJlZVNoYWtlYWJsZUljb24ucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogQ29sb3Igb2YgaWNvbi4gRXF1aXZhbGVudCB0byBzZXR0aW5nIENTUyBgZmlsbGAgcHJvcGVydHkuXG4gICAqL1xuICBjb2xvcjogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogU2l6ZSBvZiB0aGUgaWNvbiwgaW4gcGl4ZWxzLlxuICAgKiBCbHVlcHJpbnQgY29udGFpbnMgMTZweCBhbmQgMjBweCBTVkcgaWNvbiBpbWFnZXMsXG4gICAqIGFuZCBjaG9vc2VzIHRoZSBhcHByb3ByaWF0ZSByZXNvbHV0aW9uIGJhc2VkIG9uIHRoaXMgcHJvcC5cbiAgICovXG4gIHNpemU6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIGljb25cbiAgICovXG4gIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIERlc2NyaXB0aW9uIHN0cmluZy5cbiAgICogQnJvd3NlcnMgdXN1YWxseSByZW5kZXIgdGhpcyBhcyBhIHRvb2x0aXAgb24gaG92ZXIsIHdoZXJlYXMgc2NyZWVuXG4gICAqIHJlYWRlcnMgd2lsbCB1c2UgaXQgZm9yIGF1cmFsIGZlZWRiYWNrLlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGlzIHNldCB0byB0aGUgaWNvbidzIG5hbWUgZm9yIGFjY2Vzc2liaWxpdHkuXG4gICAqL1xuICB0aXRsZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQ1NTIHN0eWxlIHByb3BlcnRpZXMuXG4gICAqL1xuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcblxuICBzdmdQYXRoczE2OiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKS5pc1JlcXVpcmVkLFxuXG4gIHN2Z1BhdGhzMjA6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLmlzUmVxdWlyZWRcbn1cblxuZXhwb3J0IGRlZmF1bHQgVHJlZVNoYWtlYWJsZUljb25cbiJdfQ==