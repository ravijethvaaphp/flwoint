import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import { dimensions, spacing, position, layout } from 'ui-box';
import { Text } from '../../typography';
import { Icon } from '../../icon';
import { Spinner } from '../../spinner';
import { withTheme } from '../../theme';
import { CaretDownIcon } from '../../icons';

var TextDropdownButton =
/*#__PURE__*/
function (_PureComponent) {
  _inherits(TextDropdownButton, _PureComponent);

  function TextDropdownButton() {
    _classCallCheck(this, TextDropdownButton);

    return _possibleConstructorReturn(this, _getPrototypeOf(TextDropdownButton).apply(this, arguments));
  }

  _createClass(TextDropdownButton, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          theme = _this$props.theme,
          className = _this$props.className,
          intent = _this$props.intent,
          height = _this$props.height,
          isActive = _this$props.isActive,
          children = _this$props.children,
          disabled = _this$props.disabled,
          appearance = _this$props.appearance,
          isLoading = _this$props.isLoading,
          paddingRight = _this$props.paddingRight,
          paddingLeft = _this$props.paddingLeft,
          paddingTop = _this$props.paddingTop,
          paddingBottom = _this$props.paddingBottom,
          icon = _this$props.icon,
          props = _objectWithoutProperties(_this$props, ["theme", "className", "intent", "height", "isActive", "children", "disabled", "appearance", "isLoading", "paddingRight", "paddingLeft", "paddingTop", "paddingBottom", "icon"]);

      var themedClassName = theme.getTextDropdownButtonClassName();
      return React.createElement(Text, _extends({
        is: "button",
        className: themedClassName,
        paddingX: 4,
        marginX: -4,
        paddingY: 2,
        marginY: -2,
        size: 300,
        "data-active": isActive
      }, TextDropdownButton.styles, props, {
        disabled: disabled
      }), isLoading && React.createElement(Spinner, {
        marginLeft: -Math.round(height / 8),
        marginRight: Math.round(height / 4),
        size: Math.round(height / 2)
      }), children, React.createElement(Icon, {
        color: "default",
        icon: icon,
        size: 12,
        marginLeft: 2
      }));
    }
  }]);

  return TextDropdownButton;
}(PureComponent);

TextDropdownButton.displayName = "TextDropdownButton";

_defineProperty(TextDropdownButton, "propTypes", _objectSpread({}, dimensions.propTypes, {}, spacing.propTypes, {}, position.propTypes, {}, layout.propTypes, {
  /**
   * Forcefully set the active state of a button.
   * Useful in conjuction with a Popover.
   */
  isActive: PropTypes.bool,

  /**
   * When true, the button is disabled.
   * isLoading also sets the button to disabled.
   */
  disabled: PropTypes.bool,

  /**
   * Name of the icon, or an icon element to render.
   * This prop is required because it determines the content of the component, but it can
   * be explicitly set to falsy values to render nothing.
   *
   * - If `null` or `undefined` or `false`, this component will render nothing.
   * - If given an IconName string literal, it will render the corresponding Evergreen icon
   * - If given a valid React element reference, it will be rendered with the other icon props
   * - Any other value will be returned as a pass-through (as if you didn't use `<Icon />`)
   */
  icon: PropTypes.oneOfType([PropTypes.elementType, PropTypes.element, PropTypes.string]),

  /**
   * Theme provided by ThemeProvider.
   */
  theme: PropTypes.object.isRequired,

  /**
   * Class name passed to the button.
   * Only use if you know what you are doing.
   */
  className: PropTypes.string
}));

_defineProperty(TextDropdownButton, "defaultProps", {
  isActive: false,
  icon: CaretDownIcon
});

_defineProperty(TextDropdownButton, "styles", {
  position: 'relative',
  fontFamily: 'ui',
  fontWeight: 500,
  display: 'inline-flex',
  alignItems: 'center',
  flexWrap: 'nowrap'
});

export default withTheme(TextDropdownButton);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9idXR0b25zL3NyYy9UZXh0RHJvcGRvd25CdXR0b24uanMiXSwibmFtZXMiOlsiUmVhY3QiLCJQdXJlQ29tcG9uZW50IiwiUHJvcFR5cGVzIiwiZGltZW5zaW9ucyIsInNwYWNpbmciLCJwb3NpdGlvbiIsImxheW91dCIsIlRleHQiLCJJY29uIiwiU3Bpbm5lciIsIndpdGhUaGVtZSIsIkNhcmV0RG93bkljb24iLCJUZXh0RHJvcGRvd25CdXR0b24iLCJwcm9wcyIsInRoZW1lIiwiY2xhc3NOYW1lIiwiaW50ZW50IiwiaGVpZ2h0IiwiaXNBY3RpdmUiLCJjaGlsZHJlbiIsImRpc2FibGVkIiwiYXBwZWFyYW5jZSIsImlzTG9hZGluZyIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJpY29uIiwidGhlbWVkQ2xhc3NOYW1lIiwiZ2V0VGV4dERyb3Bkb3duQnV0dG9uQ2xhc3NOYW1lIiwic3R5bGVzIiwiTWF0aCIsInJvdW5kIiwicHJvcFR5cGVzIiwiYm9vbCIsIm9uZU9mVHlwZSIsImVsZW1lbnRUeXBlIiwiZWxlbWVudCIsInN0cmluZyIsIm9iamVjdCIsImlzUmVxdWlyZWQiLCJmb250RmFtaWx5IiwiZm9udFdlaWdodCIsImRpc3BsYXkiLCJhbGlnbkl0ZW1zIiwiZmxleFdyYXAiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxPQUFPQSxLQUFQLElBQWdCQyxhQUFoQixRQUFxQyxPQUFyQztBQUNBLE9BQU9DLFNBQVAsTUFBc0IsWUFBdEI7QUFDQSxTQUFTQyxVQUFULEVBQXFCQyxPQUFyQixFQUE4QkMsUUFBOUIsRUFBd0NDLE1BQXhDLFFBQXNELFFBQXREO0FBQ0EsU0FBU0MsSUFBVCxRQUFxQixrQkFBckI7QUFDQSxTQUFTQyxJQUFULFFBQXFCLFlBQXJCO0FBQ0EsU0FBU0MsT0FBVCxRQUF3QixlQUF4QjtBQUNBLFNBQVNDLFNBQVQsUUFBMEIsYUFBMUI7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QUFFZG9DLEVBQUFBLFVBQVUsRUFBRSxJQUZFO0FBR2RDLEVBQUFBLFVBQVUsRUFBRSxHQUhFO0FBSWRDLEVBQUFBLE9BQU8sRUFBRSxhQUpLO0FBS2RDLEVBQUFBLFVBQVUsRUFBRSxRQUxFO0FBTWRDLEVBQUFBLFFBQVEsRUFBRTtBQU5JLEM7O0FBZ0VsQixlQUFlbkMsU0FBUyxDQUFDRSxrQkFBRCxDQUF4QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgeyBkaW1lbnNpb25zLCBzcGFjaW5nLCBwb3NpdGlvbiwgbGF5b3V0IH0gZnJvbSAndWktYm94J1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uLy4uL3R5cG9ncmFwaHknXG5pbXBvcnQgeyBJY29uIH0gZnJvbSAnLi4vLi4vaWNvbidcbmltcG9ydCB7IFNwaW5uZXIgfSBmcm9tICcuLi8uLi9zcGlubmVyJ1xuaW1wb3J0IHsgd2l0aFRoZW1lIH0gZnJvbSAnLi4vLi4vdGhlbWUnXG5pbXBvcnQgeyBDYXJldERvd25JY29uIH0gZnJvbSAnLi4vLi4vaWNvbnMnXG5cbmNsYXNzIFRleHREcm9wZG93bkJ1dHRvbiBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIC8qKlxuICAgICAqIENvbXBvc2VzIHRoZSBkaW1lbnNpb25zIHNwZWMgZnJvbSB0aGUgQm94IHByaW1pdGl2ZS5cbiAgICAgKi9cbiAgICAuLi5kaW1lbnNpb25zLnByb3BUeXBlcyxcblxuICAgIC8qKlxuICAgICAqIENvbXBvc2VzIHRoZSBzcGFjaW5nIHNwZWMgZnJvbSB0aGUgQm94IHByaW1pdGl2ZS5cbiAgICAgKi9cbiAgICAuLi5zcGFjaW5nLnByb3BUeXBlcyxcblxuICAgIC8qKlxuICAgICAqIENvbXBvc2VzIHRoZSBwb3NpdGlvbiBzcGVjIGZyb20gdGhlIEJveCBwcmltaXRpdmUuXG4gICAgICovXG4gICAgLi4ucG9zaXRpb24ucHJvcFR5cGVzLFxuXG4gICAgLyoqXG4gICAgICogQ29tcG9zZXMgdGhlIGxheW91dCBzcGVjIGZyb20gdGhlIEJveCBwcmltaXRpdmUuXG4gICAgICovXG4gICAgLi4ubGF5b3V0LnByb3BUeXBlcyxcblxuICAgIC8qKlxuICAgICAqIEZvcmNlZnVsbHkgc2V0IHRoZSBhY3RpdmUgc3RhdGUgb2YgYSBidXR0b24uXG4gICAgICogVXNlZnVsIGluIGNvbmp1Y3Rpb24gd2l0aCBhIFBvcG92ZXIuXG4gICAgICovXG4gICAgaXNBY3RpdmU6IFByb3BUeXBlcy5ib29sLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0aGUgYnV0dG9uIGlzIGRpc2FibGVkLlxuICAgICAqIGlzTG9hZGluZyBhbHNvIHNldHMgdGhlIGJ1dHRvbiB0byBkaXNhYmxlZC5cbiAgICAgKi9cbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoZSBpY29uLCBvciBhbiBpY29uIGVsZW1lbnQgdG8gcmVuZGVyLlxuICAgICAqIFRoaXMgcHJvcCBpcyByZXF1aXJlZCBiZWNhdXNlIGl0IGRldGVybWluZXMgdGhlIGNvbnRlbnQgb2YgdGhlIGNvbXBvbmVudCwgYnV0IGl0IGNhblxuICAgICAqIGJlIGV4cGxpY2l0bHkgc2V0IHRvIGZhbHN5IHZhbHVlcyB0byByZW5kZXIgbm90aGluZy5cbiAgICAgKlxuICAgICAqIC0gSWYgYG51bGxgIG9yIGB1bmRlZmluZWRgIG9yIGBmYWxzZWAsIHRoaXMgY29tcG9uZW50IHdpbGwgcmVuZGVyIG5vdGhpbmcuXG4gICAgICogLSBJZiBnaXZlbiBhbiBJY29uTmFtZSBzdHJpbmcgbGl0ZXJhbCwgaXQgd2lsbCByZW5kZXIgdGhlIGNvcnJlc3BvbmRpbmcgRXZlcmdyZWVuIGljb25cbiAgICAgKiAtIElmIGdpdmVuIGEgdmFsaWQgUmVhY3QgZWxlbWVudCByZWZlcmVuY2UsIGl0IHdpbGwgYmUgcmVuZGVyZWQgd2l0aCB0aGUgb3RoZXIgaWNvbiBwcm9wc1xuICAgICAqIC0gQW55IG90aGVyIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQgYXMgYSBwYXNzLXRocm91Z2ggKGFzIGlmIHlvdSBkaWRuJ3QgdXNlIGA8SWNvbiAvPmApXG4gICAgICovXG4gICAgaWNvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICBQcm9wVHlwZXMuZWxlbWVudFR5cGUsXG4gICAgICBQcm9wVHlwZXMuZWxlbWVudCxcbiAgICAgIFByb3BUeXBlcy5zdHJpbmdcbiAgICBdKSxcblxuICAgIC8qKlxuICAgICAqIFRoZW1lIHByb3ZpZGVkIGJ5IFRoZW1lUHJvdmlkZXIuXG4gICAgICovXG4gICAgdGhlbWU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIENsYXNzIG5hbWUgcGFzc2VkIHRvIHRoZSBidXR0b24uXG4gICAgICogT25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxuICAgICAqL1xuICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZ1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBpc0FjdGl2ZTogZmFsc2UsXG4gICAgaWNvbjogQ2FyZXREb3duSWNvblxuICB9XG5cbiAgc3RhdGljIHN0eWxlcyA9IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICBmb250RmFtaWx5OiAndWknLFxuICAgIGZvbnRXZWlnaHQ6IDUwMCxcbiAgICBkaXNwbGF5OiAnaW5saW5lLWZsZXgnLFxuICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgIGZsZXhXcmFwOiAnbm93cmFwJ1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRoZW1lLFxuICAgICAgY2xhc3NOYW1lLFxuXG4gICAgICBpbnRlbnQsXG4gICAgICBoZWlnaHQsXG4gICAgICBpc0FjdGl2ZSxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZGlzYWJsZWQsXG4gICAgICBhcHBlYXJhbmNlLFxuICAgICAgaXNMb2FkaW5nLFxuXG4gICAgICAvLyBQYWRkaW5nc1xuICAgICAgcGFkZGluZ1JpZ2h0LFxuICAgICAgcGFkZGluZ0xlZnQsXG4gICAgICBwYWRkaW5nVG9wLFxuICAgICAgcGFkZGluZ0JvdHRvbSxcblxuICAgICAgLy8gSWNvbnNcbiAgICAgIGljb24sXG5cbiAgICAgIC4uLnByb3BzXG4gICAgfSA9IHRoaXMucHJvcHNcblxuICAgIGNvbnN0IHRoZW1lZENsYXNzTmFtZSA9IHRoZW1lLmdldFRleHREcm9wZG93bkJ1dHRvbkNsYXNzTmFtZSgpXG5cbiAgICByZXR1cm4gKFxuICAgICAgPFRleHRcbiAgICAgICAgaXM9XCJidXR0b25cIlxuICAgICAgICBjbGFzc05hbWU9e3RoZW1lZENsYXNzTmFtZX1cbiAgICAgICAgcGFkZGluZ1g9ezR9XG4gICAgICAgIG1hcmdpblg9ey00fVxuICAgICAgICBwYWRkaW5nWT17Mn1cbiAgICAgICAgbWFyZ2luWT17LTJ9XG4gICAgICAgIHNpemU9ezMwMH1cbiAgICAgICAgZGF0YS1hY3RpdmU9e2lzQWN0aXZlfVxuICAgICAgICB7Li4uVGV4dERyb3Bkb3duQnV0dG9uLnN0eWxlc31cbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICA+XG4gICAgICAgIHtpc0xvYWRpbmcgJiYgKFxuICAgICAgICAgIDxTcGlubmVyXG4gICAgICAgICAgICBtYXJnaW5MZWZ0PXstTWF0aC5yb3VuZChoZWlnaHQgLyA4KX1cbiAgICAgICAgICAgIG1hcmdpblJpZ2h0PXtNYXRoLnJvdW5kKGhlaWdodCAvIDQpfVxuICAgICAgICAgICAgc2l6ZT17TWF0aC5yb3VuZChoZWlnaHQgLyAyKX1cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDxJY29uIGNvbG9yPVwiZGVmYXVsdFwiIGljb249e2ljb259IHNpemU9ezEyfSBtYXJnaW5MZWZ0PXsyfSAvPlxuICAgICAgPC9UZXh0PlxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoVGhlbWUoVGV4dERyb3Bkb3duQnV0dG9uKVxuIl19