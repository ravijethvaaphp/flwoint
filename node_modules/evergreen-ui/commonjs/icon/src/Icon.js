"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Icon = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactIs = _interopRequireDefault(require("react-is"));

var IconExports = _interopRequireWildcard(require("../../icons"));

var IconNameMapper = IconExports.IconNameMapper,
    icons = (0, _objectWithoutProperties2["default"])(IconExports, ["IconNameMapper"]);

var Icon =
/*#__PURE__*/
function (_PureComponent) {
  (0, _inherits2["default"])(Icon, _PureComponent);

  function Icon() {
    (0, _classCallCheck2["default"])(this, Icon);
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Icon).apply(this, arguments));
  }

  (0, _createClass2["default"])(Icon, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          icon = _this$props.icon,
          iconProps = (0, _objectWithoutProperties2["default"])(_this$props, ["icon"]);

      if (!icon) {
        return null;
      }

      if (typeof icon === 'string') {
        var iconName = IconNameMapper[icon] || '';
        var Component = icons[iconName];

        if (Component) {
          return _react["default"].createElement(Component, iconProps);
        }
      }

      if (_reactIs["default"].isValidElementType(icon)) {
        var _Component = icon;
        return _react["default"].createElement(_Component, iconProps);
      }

      if (_react["default"].isValidElement(icon)) {
        return _react["default"].cloneElement(icon, iconProps);
      }

      return icon;
    }
  }]);
  return Icon;
}(_react.PureComponent);

exports.Icon = Icon;
Icon.displayName = "Icon";
(0, _defineProperty2["default"])(Icon, "SIZE_STANDARD", 16);
(0, _defineProperty2["default"])(Icon, "SIZE_LARGE", 20);
(0, _defineProperty2["default"])(Icon, "propTypes", {
  /**
   * Color of icon. Equivalent to setting CSS `fill` property.
   */
  color: _propTypes["default"].string,

  /**
   * Name of the icon, or an icon element to render.
   * This prop is required because it determines the content of the component, but it can
   * be explicitly set to falsy values to render nothing.
   *
   * - If `null` or `undefined` or `false`, this component will render nothing.
   * - If given an IconName string literal, it will render the corresponding Evergreen icon
   * - If given a valid React element reference, it will be rendered with the other icon props
   * - Any other value will be returned as a pass-through (as if you didn't use `<Icon />`)
   */
  icon: _propTypes["default"].oneOfType([_propTypes["default"].elementType, _propTypes["default"].element, _propTypes["default"].string]).isRequired,

  /**
   * Size of the icon, in pixels.
   * Blueprint contains 16px and 20px SVG icon images,
   * and chooses the appropriate resolution based on this prop.
   */
  size: _propTypes["default"].number.isRequired,

  /**
   * Description string.
   * Browsers usually render this as a tooltip on hover, whereas screen
   * readers will use it for aural feedback.
   * By default, this is set to the icon's name for accessibility.
   */
  title: _propTypes["default"].string,

  /**
   * CSS style properties.
   */
  style: _propTypes["default"].object
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9pY29uL3NyYy9JY29uLmpzIl0sIm5hbWVzIjpbIkljb25OYW1lTWFwcGVyIiwiSWNvbkV4cG9ydHMiLCJpY29ucyIsIkljb24iLCJwcm9wcyIsImljb24iLCJpY29uUHJvcHMiLCJpY29uTmFtZSIsIkNvbXBvbmVudCIsIlJlYWN0SXMiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJSZWFjdCIsImlzVmFsaWRFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwiUHVyZUNvbXBvbmVudCIsImNvbG9yIiwiUHJvcFR5cGVzIiwic3RyaW5nIiwib25lT2ZUeXBlIiwiZWxlbWVudFR5cGUiLCJlbGVtZW50IiwiaXNSZXF1aXJlZCIsInNpemUiLCJudW1iZXIiLCJ0aXRsZSIsInN0eWxlIiwib2JqZWN0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0lBRVFBLGMsR0FBNkJDLFcsQ0FBN0JELGM7SUFBbUJFLEssNkNBQVVELFc7O0lBRXhCRSxJOzs7Ozs7Ozs7Ozs7NkJBK0NGO0FBQUEsd0JBQ3dCLEtBQUtDLEtBRDdCO0FBQUEsVUFDQ0MsSUFERCxlQUNDQSxJQUREO0FBQUEsVUFDVUMsU0FEVjs7QUFHUCxVQUFJLENBQUNELElBQUwsRUFBVztBQUNULGVBQU8sSUFBUDtBQUNEOztBQUVELFVBQUksT0FBT0EsSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUM1QixZQUFNRSxRQUFRLEdBQUdQLGNBQWMsQ0FBQ0ssSUFBRCxDQUFkLElBQXdCLEVBQXpDO0FBQ0EsWUFBTUcsU0FBUyxHQUFHTixLQUFLLENBQUNLLFFBQUQsQ0FBdkI7O0FBQ0EsWUFBSUMsU0FBSixFQUFlO0FBQ2IsaUJBQU8sZ0NBQUMsU0FBRCxFQUFlRixTQUFmLENBQVA7QUFDRDtBQUNGOztBQUVELFVBQUlHLG9CQUFRQyxrQkFBUixDQUEyQkwsSUFBM0IsQ0FBSixFQUFzQztBQUNwQyxZQUFNRyxVQUFTLEdBQUdILElBQWxCO0FBQ0EsZUFBTyxnQ0FBQyxVQUFELEVBQWVDLFNBQWYsQ0FBUDtBQUNEOztBQUVELFVBQUlLLGtCQUFNQyxjQUFOLENBQXFCUCxJQUFyQixDQUFKLEVBQWdDO0FBQzlCLGVBQU9NLGtCQUFNRSxZQUFOLENBQW1CUixJQUFuQixFQUF5QkMsU0FBekIsQ0FBUDtBQUNEOztBQUVELGFBQU9ELElBQVA7QUFDRDs7O0VBeEV1QlMsb0I7OztBQUFiWCxJO2lDQUFBQSxJLG1CQUNZLEU7aUNBRFpBLEksZ0JBRVMsRTtpQ0FGVEEsSSxlQUlRO0FBQ2pCOzs7QUFHQVksRUFBQUEsS0FBSyxFQUFFQyxzQkFBVUMsTUFKQTs7QUFNakI7Ozs7Ozs7Ozs7QUFVQVosRUFBQUEsSUFBSSxFQUFFVyxzQkFBVUUsU0FBVixDQUFvQixDQUN4QkYsc0JBQVVHLFdBRGMsRUFFeEJILHNCQUFVSSxPQUZjLEVBR3hCSixzQkFBVUMsTUFIYyxDQUFwQixFQUlISSxVQXBCYzs7QUFzQmpCOzs7OztBQUtBQyxFQUFBQSxJQUFJLEVBQUVOLHNCQUFVTyxNQUFWLENBQWlCRixVQTNCTjs7QUE2QmpCOzs7Ozs7QUFNQUcsRUFBQUEsS0FBSyxFQUFFUixzQkFBVUMsTUFuQ0E7O0FBcUNqQjs7O0FBR0FRLEVBQUFBLEtBQUssRUFBRVQsc0JBQVVVO0FBeENBLEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJ1xuaW1wb3J0IFJlYWN0SXMgZnJvbSAncmVhY3QtaXMnXG5pbXBvcnQgKiBhcyBJY29uRXhwb3J0cyBmcm9tICcuLi8uLi9pY29ucydcblxuY29uc3QgeyBJY29uTmFtZU1hcHBlciwgLi4uaWNvbnMgfSA9IEljb25FeHBvcnRzXG5cbmV4cG9ydCBjbGFzcyBJY29uIGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gIHN0YXRpYyBTSVpFX1NUQU5EQVJEID0gMTZcbiAgc3RhdGljIFNJWkVfTEFSR0UgPSAyMFxuXG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgaWNvbi4gRXF1aXZhbGVudCB0byBzZXR0aW5nIENTUyBgZmlsbGAgcHJvcGVydHkuXG4gICAgICovXG4gICAgY29sb3I6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoZSBpY29uLCBvciBhbiBpY29uIGVsZW1lbnQgdG8gcmVuZGVyLlxuICAgICAqIFRoaXMgcHJvcCBpcyByZXF1aXJlZCBiZWNhdXNlIGl0IGRldGVybWluZXMgdGhlIGNvbnRlbnQgb2YgdGhlIGNvbXBvbmVudCwgYnV0IGl0IGNhblxuICAgICAqIGJlIGV4cGxpY2l0bHkgc2V0IHRvIGZhbHN5IHZhbHVlcyB0byByZW5kZXIgbm90aGluZy5cbiAgICAgKlxuICAgICAqIC0gSWYgYG51bGxgIG9yIGB1bmRlZmluZWRgIG9yIGBmYWxzZWAsIHRoaXMgY29tcG9uZW50IHdpbGwgcmVuZGVyIG5vdGhpbmcuXG4gICAgICogLSBJZiBnaXZlbiBhbiBJY29uTmFtZSBzdHJpbmcgbGl0ZXJhbCwgaXQgd2lsbCByZW5kZXIgdGhlIGNvcnJlc3BvbmRpbmcgRXZlcmdyZWVuIGljb25cbiAgICAgKiAtIElmIGdpdmVuIGEgdmFsaWQgUmVhY3QgZWxlbWVudCByZWZlcmVuY2UsIGl0IHdpbGwgYmUgcmVuZGVyZWQgd2l0aCB0aGUgb3RoZXIgaWNvbiBwcm9wc1xuICAgICAqIC0gQW55IG90aGVyIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQgYXMgYSBwYXNzLXRocm91Z2ggKGFzIGlmIHlvdSBkaWRuJ3QgdXNlIGA8SWNvbiAvPmApXG4gICAgICovXG4gICAgaWNvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICBQcm9wVHlwZXMuZWxlbWVudFR5cGUsXG4gICAgICBQcm9wVHlwZXMuZWxlbWVudCxcbiAgICAgIFByb3BUeXBlcy5zdHJpbmdcbiAgICBdKS5pc1JlcXVpcmVkLFxuXG4gICAgLyoqXG4gICAgICogU2l6ZSBvZiB0aGUgaWNvbiwgaW4gcGl4ZWxzLlxuICAgICAqIEJsdWVwcmludCBjb250YWlucyAxNnB4IGFuZCAyMHB4IFNWRyBpY29uIGltYWdlcyxcbiAgICAgKiBhbmQgY2hvb3NlcyB0aGUgYXBwcm9wcmlhdGUgcmVzb2x1dGlvbiBiYXNlZCBvbiB0aGlzIHByb3AuXG4gICAgICovXG4gICAgc2l6ZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpcHRpb24gc3RyaW5nLlxuICAgICAqIEJyb3dzZXJzIHVzdWFsbHkgcmVuZGVyIHRoaXMgYXMgYSB0b29sdGlwIG9uIGhvdmVyLCB3aGVyZWFzIHNjcmVlblxuICAgICAqIHJlYWRlcnMgd2lsbCB1c2UgaXQgZm9yIGF1cmFsIGZlZWRiYWNrLlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgaXMgc2V0IHRvIHRoZSBpY29uJ3MgbmFtZSBmb3IgYWNjZXNzaWJpbGl0eS5cbiAgICAgKi9cbiAgICB0aXRsZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAgIC8qKlxuICAgICAqIENTUyBzdHlsZSBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBpY29uLCAuLi5pY29uUHJvcHMgfSA9IHRoaXMucHJvcHNcblxuICAgIGlmICghaWNvbikge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGljb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBpY29uTmFtZSA9IEljb25OYW1lTWFwcGVyW2ljb25dIHx8ICcnXG4gICAgICBjb25zdCBDb21wb25lbnQgPSBpY29uc1tpY29uTmFtZV1cbiAgICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIDxDb21wb25lbnQgey4uLmljb25Qcm9wc30gLz5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUoaWNvbikpIHtcbiAgICAgIGNvbnN0IENvbXBvbmVudCA9IGljb25cbiAgICAgIHJldHVybiA8Q29tcG9uZW50IHsuLi5pY29uUHJvcHN9IC8+XG4gICAgfVxuXG4gICAgaWYgKFJlYWN0LmlzVmFsaWRFbGVtZW50KGljb24pKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGljb24sIGljb25Qcm9wcylcbiAgICB9XG5cbiAgICByZXR1cm4gaWNvblxuICB9XG59XG4iXX0=